# Implement changes for board generation
_Exported on 12/09/2025 at 14:10:30 BST from Cursor (1.4.5)_

---

**User**

You are a language model, working as part of a team to implement a research proposal. Please take the time to read the ResearchPlan.md. 
Your colleagues have implemented steps 1.1 - 1.3 of the plan, and these have been checked and are deemed completed. 
We are now in stage 1.4, the initial testing of the environment, and your job is to assist me in making some changes to the way the environment is generated. 

In particular, we want to make changes to ensure the generated boards satisfy some specifications, as detailed in 'env/WallSpecifications.md'. Any board generated should satisfy these conditions. This should respect reproducability under the same random seed, and should not involve generating and then testing for conditions afterward and accepting/rejecting a board based on this (since there are a lot of conditions, this would take a long time when we need to generate a new board), so it should instead be done in a constructive way.

Please go ahead and implement these changes. If you are uncertain or have questions, you can ask them.

---

**Cursor**

I'll scan the research plan and the environment code, plus the wall specifications, to understand how boards are currently generated and where to integrate constructive constraints. Then I'll update the generator to enforce the specs while preserving seed-based reproducibility.

I'll scan the tests to see how the environment expects board generation to work and to detect any existing references to the specified wall structures, so I can integrate changes without breaking tests.

I'll quickly scan the remaining tests to see any expectations around random board generation, so I can preserve interfaces and not break tests while adding the constructive generator.

I'll implement a constructive board generator in `env/ricochet_env.py` that enforces the wall specifications, add configurable per-quadrant counts with sensible defaults, and ensure robots/goal placement respects the central block. Then I'll run linters on the modified file to catch any issues.

I'll add new parameters and a constructive generator to `env/ricochet_env.py`, replacing `_generate_random_board` to build walls by quadrant (edge-T and central-L), add central forbidden block, then place robots/goal outside it. I'll keep RNG via `self.np_random` for reproducibility. Now I'll make the edits.

I'm going to add new configuration parameters and replace the random board generator with a constructive generator that builds the forbidden central block, per-quadrant edge-T and central-L structures with balanced orientations, and places robots/goal outside the central block while maintaining seed-based reproducibility. Then I'll run a linter check on the modified file.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for name, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for name, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

I updated the generator to construct boards that follow the `WallSpecifications.md` rules with per-quadrant counts and central block constraints, and added configuration options. I'll run a linter on `env/ricochet_env.py` and then mark the completed tasks.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

- I added a constructive generator in `env/ricochet_env.py` that:
  - Enforces square boards and builds the forbidden central block (1x1 for odd, 2x2 for even), and excludes robots/goal from it.
  - Places per-quadrant wall structures: edge-T at borders and central-L inside, using `self.np_random` for reproducibility.
  - Distributes central-L orientations as evenly as possible within each quadrant.
  - Ensures no cell hosts more than one structure.
  - Exposes `edge_t_per_quadrant` and `central_l_per_quadrant` with defaults: 2 if side < 10 else 4.
- I ran lints; fixed a minor warning.

Would you like me to add unit tests to verify these wall-spec constraints and reproducibility under a fixed seed?

---

**User**

I forgot one rule: 
- Central-L structures cannot be around an edge square

---

**Cursor**

I'll update the central-L placement to exclude edge cells explicitly, ensuring no central-L is placed around an edge square. I'll make the change now.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Done. Central-L placement now skips edge cells, so no central-L can be around an edge square.

- Updated `place_central_l_in_quadrant` to filter out edge cells before considering candidates.
- Lints clean.

Want me to add tests to assert this constraint?

---

**User**

Sorry, another requirement: Any cell with a wall around it (excluding boundary edge walls, but including walls from central-L, jutting walls from edge-T or the forbidden-central-block) cannot have any of its neighbours be the square around which a central-L or edge-T block is formed.

---

**Cursor**

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Applied the new constraint:

- Central-L candidates now skip any cell whose 4-neighbors include a cell that already has a non-boundary wall.
- Edge-T placement now checks its prospective center cell isnt adjacent to any cell with a non-boundary wall before placing.
- This enforces: any cell with a non-boundary wall cannot have its neighbors be centers of edge-T or central-L structures.

All lints are clean. Want me to add tests to verify this rule?

---

**User**

env.reset is no longer deterministic, which it should be according to step 1.3 of the plan outlined in ResearchPlan.md. Please fix this.

---

**Cursor**

I'll update the environment to ensure that repeated calls to reset without providing a new seed produce the same board when a base seed was given, by storing a base seed and re-initializing the RNG on every reset with that base seed unless a new seed is provided.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        # Preserve a base seed to enforce deterministic resets when no new seed is provided
        self._base_seed: Optional[int] = int(seed) if seed is not None else self._episode_seed
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
            self._base_seed = int(self._episode_seed) if self._episode_seed is not None else None
        else:
            # Re-seed with base seed so that resets are deterministic when no new seed is provided
            if self._base_seed is not None:
                try:
                    self.np_random, used_seed = _seeding.np_random(self._base_seed)  # type: ignore[name-defined]
                    self._episode_seed = int(used_seed) if used_seed is not None else int(self._base_seed)
                except NameError:
                    self.np_random = np.random.default_rng(self._base_seed)
                    self._episode_seed = int(self._base_seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Fixed determinism:

- The env now stores a base seed on init and, if `reset` is called without a new seed, it re-initializes the RNG from that base seed so the generated board repeats deterministically.
- Providing a new seed to `reset(seed=...)` replaces the base seed for subsequent resets.

This aligns with Step 1.3 reproducibility.

---

**User**

Thank you, good job! One more rule to implement: Edge-T structure cannot produce jutting walls which are boundaries to walls on the corner. So for example, an edge-T structure which places a jutting vertical wall to the right of (0,1) is okay, but an edge-T strucutre which places a jutting vertial wall to the left of (0,1) or equivalently to the right of (0,0) is not okay

---

**Cursor**

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        # Preserve a base seed to enforce deterministic resets when no new seed is provided
        self._base_seed: Optional[int] = int(seed) if seed is not None else self._episode_seed
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
            self._base_seed = int(self._episode_seed) if self._episode_seed is not None else None
        else:
            # Re-seed with base seed so that resets are deterministic when no new seed is provided
            if self._base_seed is not None:
                try:
                    self.np_random, used_seed = _seeding.np_random(self._base_seed)  # type: ignore[name-defined]
                    self._episode_seed = int(used_seed) if used_seed is not None else int(self._base_seed)
                except NameError:
                    self.np_random = np.random.default_rng(self._base_seed)
                    self._episode_seed = int(self._base_seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Disallow juts adjacent to board corners along top/bottom: c must not be 1 or w-1
                    if c in (1, w - 1):
                        continue
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Disallow juts adjacent to board corners along left/right: r must not be 1 or h-1
                    if r in (1, h - 1):
                        continue
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Implemented the corner-adjacency rule for edge-T:

- For top/bottom edge-T juts (vertical walls), I now skip positions where c is 1 or w-1 to avoid juts that abut the top-left/top-right or bottom-left/bottom-right corners.
- For left/right edge-T juts (horizontal walls), I skip positions where r is 1 or h-1 to avoid juts that abut the corners vertically.
- Keeps existing constraints (no neighbor-of-walled cell can be a center, etc.).

All lints clean.

---

**User**

Amazing, thank you! Please can you add another rendering mode, RGB, which will render as an rgb array? I would like this to be configurable, with the defaults to be something like:

- squares indicated as faint gray lines
- walls indicated as thicker black lines
- robots indicated as circles of given colours (eg. red, blue, green, yellow)
- target square indicated as a star of the colour corresponding to the target robot (but a darker version of this colour)

Please implement this, and add an example of this to the initial_testing_cells.py script.

---

**Cursor**

I'll add a new RGB rendering mode to the environment with configurable defaults, then update the initial testing script to show an example image generated and saved/displayed.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii", "rgb"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
        # RGB render configuration
        render_rgb_config: Optional[Dict[str, object]] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        # RGB render defaults
        self._render_rgb_cfg: Dict[str, object] = {
            "cell_size": 20,
            "grid_color": (200, 200, 200),
            "grid_thickness": 1,
            "wall_color": (0, 0, 0),
            "wall_thickness": 3,
            "robot_colors": [
                (220, 50, 50),     # red
                (50, 120, 220),    # blue
                (50, 180, 80),     # green
                (230, 200, 40),    # yellow
                (180, 80, 180),    # purple (extra if more robots)
            ],
            "circle_fill": True,
            "circle_radius_frac": 0.35,
            "target_dark_factor": 0.6,
            "star_thickness": 2,
        }
        if render_rgb_config is not None:
            self._render_rgb_cfg.update(render_rgb_config)

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        # Preserve a base seed to enforce deterministic resets when no new seed is provided
        self._base_seed: Optional[int] = int(seed) if seed is not None else self._episode_seed
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
            self._base_seed = int(self._episode_seed) if self._episode_seed is not None else None
        else:
            # Re-seed with base seed so that resets are deterministic when no new seed is provided
            if self._base_seed is not None:
                try:
                    self.np_random, used_seed = _seeding.np_random(self._base_seed)  # type: ignore[name-defined]
                    self._episode_seed = int(used_seed) if used_seed is not None else int(self._base_seed)
                except NameError:
                    self.np_random = np.random.default_rng(self._base_seed)
                    self._episode_seed = int(self._base_seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode=="rgb": returns an (H_px, W_px, 3) uint8 array.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self._board is None:
            return "" if self.render_mode == "ascii" else None
        if self.render_mode == "ascii":
            from .ricochet_core import render_ascii  # local import to avoid circulars in lints
            return render_ascii(self._board)
        if self.render_mode == "rgb":
            return self._render_rgb(self._board)
        if self._board is None:
            return ""
        raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Disallow juts adjacent to board corners along top/bottom: c must not be 1 or w-1
                    if c in (1, w - 1):
                        continue
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Disallow juts adjacent to board corners along left/right: r must not be 1 or h-1
                    if r in (1, h - 1):
                        continue
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall

    def _render_rgb(self, board: Board) -> np.ndarray:
        # Extract config
        cfg = self._render_rgb_cfg
        cell_size = int(cfg["cell_size"])  # pixels
        grid_color = tuple(int(x) for x in cfg["grid_color"])  # type: ignore[index]
        grid_th = int(cfg["grid_thickness"])  # px
        wall_color = tuple(int(x) for x in cfg["wall_color"])  # type: ignore[index]
        wall_th = int(cfg["wall_thickness"])  # px
        robot_colors: List[Tuple[int, int, int]] = [tuple(int(a) for a in t) for t in cfg["robot_colors"]]  # type: ignore[index]
        circle_fill: bool = bool(cfg["circle_fill"])  # type: ignore[index]
        circle_r_frac: float = float(cfg["circle_radius_frac"])  # type: ignore[index]
        target_dark_factor: float = float(cfg["target_dark_factor"])  # type: ignore[index]
        star_th: int = int(cfg["star_thickness"])  # type: ignore[index]

        H, W = board.height, board.width
        H_px, W_px = H * cell_size, W * cell_size
        img = np.ones((H_px, W_px, 3), dtype=np.uint8) * 255

        # Helpers to draw
        def draw_hline(y: int, x0: int, x1: int, color: Tuple[int, int, int], thickness: int) -> None:
            y0 = max(0, y - thickness // 2)
            y1 = min(H_px, y + (thickness - thickness // 2))
            x0c = max(0, min(x0, x1))
            x1c = min(W_px, max(x0, x1))
            img[y0:y1, x0c:x1c] = color

        def draw_vline(x: int, y0: int, y1: int, color: Tuple[int, int, int], thickness: int) -> None:
            x0 = max(0, x - thickness // 2)
            x1 = min(W_px, x + (thickness - thickness // 2))
            y0c = max(0, min(y0, y1))
            y1c = min(H_px, max(y0, y1))
            img[y0c:y1c, x0:x1] = color

        def draw_circle(cx: float, cy: float, radius: float, color: Tuple[int, int, int], fill: bool) -> None:
            # Bounding box
            x0 = int(max(0, np.floor(cx - radius)))
            x1 = int(min(W_px - 1, np.ceil(cx + radius)))
            y0 = int(max(0, np.floor(cy - radius)))
            y1 = int(min(H_px - 1, np.ceil(cy + radius)))
            yy, xx = np.ogrid[y0:y1 + 1, x0:x1 + 1]
            mask = (xx - cx) ** 2 + (yy - cy) ** 2 <= radius ** 2
            if fill:
                img[y0:y1 + 1, x0:x1 + 1][mask] = color
            else:
                # outline 1px
                inner = (xx - cx) ** 2 + (yy - cy) ** 2 <= (radius - 1) ** 2
                ring = np.logical_and(mask, np.logical_not(inner))
                img[y0:y1 + 1, x0:x1 + 1][ring] = color

        def draw_star(cx: float, cy: float, arm_len: float, color: Tuple[int, int, int], thickness: int) -> None:
            # Draw + arms
            draw_hline(int(cy), int(cx - arm_len), int(cx + arm_len), color, thickness)
            draw_vline(int(cx), int(cy - arm_len), int(cy + arm_len), color, thickness)
            # Draw x arms (diagonals) by sampling small line thickness via plotting short lines of squares
            # Approximate diagonals by drawing small rectangles along the diagonal
            steps = int(arm_len)
            for s in range(-steps, steps + 1):
                x = int(cx + s)
                y1 = int(cy + s)
                y2 = int(cy - s)
                y0a = max(0, y1 - thickness // 2)
                y1a = min(H_px, y1 + (thickness - thickness // 2))
                x0a = max(0, x - thickness // 2)
                x1a = min(W_px, x + (thickness - thickness // 2))
                img[y0a:y1a, x0a:x1a] = color
                y0b = max(0, y2 - thickness // 2)
                y1b = min(H_px, y2 + (thickness - thickness // 2))
                img[y0b:y1b, x0a:x1a] = color

        # 1) Draw faint grid lines
        for r in range(H + 1):
            y = int(r * cell_size)
            draw_hline(y, 0, W_px, grid_color, grid_th)
        for c in range(W + 1):
            x = int(c * cell_size)
            draw_vline(x, 0, H_px, grid_color, grid_th)

        # 2) Draw walls as thicker black lines. h_walls[r,c] between rows r-1 and r over cell column c
        for r in range(H + 1):
            for c in range(W):
                if board.h_walls[r, c]:
                    y = int(r * cell_size)
                    x0 = int(c * cell_size)
                    x1 = int((c + 1) * cell_size)
                    draw_hline(y, x0, x1, wall_color, wall_th)
        for r in range(H):
            for c in range(W + 1):
                if board.v_walls[r, c]:
                    x = int(c * cell_size)
                    y0 = int(r * cell_size)
                    y1 = int((r + 1) * cell_size)
                    draw_vline(x, y0, y1, wall_color, wall_th)

        # 3) Draw robots as filled circles
        radius = cell_size * float(circle_r_frac)
        for rid, (rr, cc) in board.robot_positions.items():
            color = robot_colors[rid % len(robot_colors)]
            cy = rr * cell_size + cell_size * 0.5
            cx = cc * cell_size + cell_size * 0.5
            draw_circle(cx, cy, radius, color, circle_fill)

        # 4) Draw target as a star in darker color of target robot
        tr = board.target_robot
        tr_color = robot_colors[tr % len(robot_colors)]
        dark_color = tuple(int(max(0, min(255, target_dark_factor * v))) for v in tr_color)
        gr, gc = board.goal_position
        cy = gr * cell_size + cell_size * 0.5
        cx = gc * cell_size + cell_size * 0.5
        draw_star(cx, cy, arm_len=cell_size * 0.35, color=dark_color, thickness=star_th)

        return img


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

```python
#%%
"""
Ricochet Robots - Initial Environment Testing Cells

How to use:
- Run each cell independently in a Jupyter-aware editor (e.g., VS Code) that supports #%% cells.
- Edit parameters in-place and re-run cells to iterate.

This script lets you:
- Create fixed or random boards
- Render ASCII boards
- Step through custom action sequences
- Run the solver and replay its plan
- Do random rollouts for smoke testing
"""

from __future__ import annotations

from typing import Dict, Tuple, List, Optional

import numpy as np

from env.ricochet_env import RicochetRobotsEnv, FixedLayout
from env.ricochet_core import UP, DOWN, LEFT, RIGHT
from env.solver import solve_bfs, solve_astar


#%%
# Configuration: tweak these defaults and re-run this cell
HEIGHT: int = 16
WIDTH: int = 16
NUM_ROBOTS: int = 4
INCLUDE_NOOP: bool = True
OBS_MODE: str = "image"  # "image" or "symbolic"
CHANNELS_FIRST: bool = False
STEP_PENALTY: float = -0.01
NOOP_PENALTY: Optional[float] = None  # None -> use STEP_PENALTY
GOAL_REWARD: float = 1.0
MAX_STEPS: int = 100
RENDER_MODE: Optional[str] = "ascii"  # "ascii", "rgb" or None
SEED: Optional[int] = 123

# When ensuring solvable random boards
ENSURE_SOLVABLE: bool = False
SOLVER_MAX_DEPTH: int = 40
SOLVER_MAX_NODES: int = 40000


#%%
# Helper: build a simple fixed layout you can edit
def make_simple_fixed_layout() -> FixedLayout:
    H, W = HEIGHT, WIDTH
    h_walls = np.zeros((H + 1, W), dtype=bool)
    v_walls = np.zeros((H, W + 1), dtype=bool)
    # Borders
    h_walls[0, :] = True
    h_walls[H, :] = True
    v_walls[:, 0] = True
    v_walls[:, W] = True

    # Example interior walls; edit these
    # Horizontal wall between rows 2-3 at column 3
    if H > 2 and W > 3:
        h_walls[2, 3] = True
    # Vertical wall between cols 1-2 at row 4
    if H > 4 and W > 2:
        v_walls[4 - 1, 2] = True  # note: v_walls shape is (H, W+1)

    # Robot positions; ensure unique cells and inside bounds
    robots: Dict[int, Tuple[int, int]] = {}
    robots[0] = (H - 2, 1)
    if NUM_ROBOTS >= 2:
        robots[1] = (1, W - 2)
    if NUM_ROBOTS >= 3:
        robots[2] = (H // 2, W // 2)

    goal: Tuple[int, int] = (1, 1)
    target_robot: int = 0

    return FixedLayout(
        height=H,
        width=W,
        h_walls=h_walls,
        v_walls=v_walls,
        robot_positions=robots,
        goal_position=goal,
        target_robot=target_robot,
    )


#%%
# Create an environment (choose fixed_layout or random with/without ensure_solvable)
USE_FIXED: bool = False

fixed_layout: Optional[FixedLayout] = make_simple_fixed_layout() if USE_FIXED else None

env = RicochetRobotsEnv(
    height=HEIGHT,
    width=WIDTH,
    num_robots=NUM_ROBOTS,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    noop_penalty=NOOP_PENALTY,
    max_steps=MAX_STEPS,
    fixed_layout=fixed_layout,
    seed=SEED,
    ensure_solvable=ENSURE_SOLVABLE,
    solver_max_depth=SOLVER_MAX_DEPTH,
    solver_max_nodes=SOLVER_MAX_NODES,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    channels_first=CHANNELS_FIRST,
    render_mode=RENDER_MODE,
)
obs, info = env.reset()
print("Environment reset. Info:", info)
frame = env.render()
if RENDER_MODE == "ascii" and frame is not None:
    print(frame)
elif RENDER_MODE == "rgb" and frame is not None:
    import matplotlib.pyplot as plt  # type: ignore
    plt.figure(figsize=(6, 6))
    plt.imshow(frame)
    plt.title("Ricochet Robots - RGB Render")
    plt.axis("off")
    plt.show()


#%%
# Convenience: list action encoding and simple helpers
def encode_action(robot_id: int, direction: int) -> int:
    return robot_id * 4 + direction


DIRS = {"u": UP, "d": DOWN, "l": LEFT, "r": RIGHT}
DIRS_INVERSE = {v: k for k, v in DIRS.items()}
print("Action encoding: action = robot_id * 4 + direction (u=0,d=1,l=2,r=3), noop is last if enabled.")


#%%
# Step through a custom action sequence you edit here
# Each action is a tuple: (robot_id, direction), where direction in {UP, DOWN, LEFT, RIGHT}
custom_actions: List[Tuple[int, int]] = [
    (0, UP),
    (0, LEFT),
]

terminated_any = False
truncated_any = False
total_reward = 0.0

for rid, d in custom_actions:
    a = encode_action(rid, d)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"reward": reward, "terminated": terminated, "truncated": truncated, "info": step_info})
    terminated_any = terminated_any or terminated
    truncated_any = truncated_any or truncated
    if terminated or truncated:
        break

print(f"Cumulative reward: {total_reward:.3f}")


#%%
# Run solver on current board and replay its plan (BFS)
solution = solve_bfs(env._board, max_depth=SOLVER_MAX_DEPTH, max_nodes=SOLVER_MAX_NODES)  # type: ignore[attr-defined]
if solution is None:
    print("Solver did not find a plan within limits.")
else:
    print(f"BFS plan length: {len(solution)} actions")
    # Replay from a fresh reset to ensure matching transitions
    env.reset()
    total_reward = 0.0
    for rid, d in solution:
        a = encode_action(rid, d)
        obs, reward, terminated, truncated, step_info = env.step(a)
        total_reward += reward
        frame = env.render()
        if RENDER_MODE == "ascii" and frame is not None:
            print(frame)
        print({"move": (rid, d), "reward": reward, "terminated": terminated, "truncated": truncated})
        if terminated or truncated:
            break
    print(f"Cumulative reward following solver plan: {total_reward:.3f}")




#%%
# Alternative: A* with selectable heuristic
H_MODE = "admissible_zero"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
H_MODE = "admissible_one"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
#Time how long it takes to solve 1000 times
import time
start_time = time.time()
for i in range(1):
    env.reset()
    frame = env.render()
    if RENDER_MODE == "ascii":
        print(frame)
    astar_sol = solve_astar(env._board, max_depth=200, max_nodes=100000, h_mode=H_MODE)  # type: ignore[attr-defined]
end_time = time.time()
print(f"Time taken: {end_time - start_time} seconds")
if astar_sol is None:
    print("A* did not find a plan within limits.")
else:
    print(f"A* plan length: {len(astar_sol)} (mode={H_MODE})")
# Print the moves in human readable format
for rid, d in astar_sol:
    print(f"Move: {rid}, Direction: {DIRS_INVERSE[d]}")
print(f"Solve length: {len(astar_sol)}")


#%%
# Random rollout for smoke testing
import random

env.reset()
steps = 20
total_reward = 0.0
for t in range(steps):
    a = random.randrange(env.action_space.n)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"t": t + 1, "a": a, "reward": reward, "terminated": terminated, "truncated": truncated})
    if terminated or truncated:
        break
print(f"Random rollout cumulative reward: {total_reward:.3f}")


#%%
# Inspect observation format and channel names (image mode) or vector (symbolic)
if OBS_MODE == "image":
    print("Image observation shape:", obs.shape)
    if hasattr(env, "channel_names"):
        print("Channels:", env.channel_names)
        # Show which cells are occupied by each robot channel
        if not CHANNELS_FIRST:
            base = 6
            for rid in range(NUM_ROBOTS):
                ch = base + rid
                count = int(np.count_nonzero(obs[:, :, ch]))
                print(f"robot_{rid} nonzeros:", count)
else:
    print("Symbolic observation vector length:", obs.shape)
    print("obs:", obs)


#%%
# Build a custom layout from scratch (advanced):
# - Edit the arrays h_walls and v_walls to draw edge walls.
# - Set robots and goal, then rebuild env with this layout.
H2, W2 = HEIGHT, WIDTH
h_walls2 = np.zeros((H2 + 1, W2), dtype=bool)
v_walls2 = np.zeros((H2, W2 + 1), dtype=bool)
# Borders
h_walls2[0, :] = True
h_walls2[H2, :] = True
v_walls2[:, 0] = True
v_walls2[:, W2] = True

# Example interior: make a small room top-left
if H2 > 3 and W2 > 3:
    h_walls2[1, 1] = True
    h_walls2[1, 2] = True
    v_walls2[1, 1] = True

robots2: Dict[int, Tuple[int, int]] = {i: (i % H2, (i * 2) % W2) for i in range(NUM_ROBOTS)}
goal2: Tuple[int, int] = (H2 - 2, W2 - 2)
target2: int = 0

layout2 = FixedLayout(
    height=H2,
    width=W2,
    h_walls=h_walls2,
    v_walls=v_walls2,
    robot_positions=robots2,
    goal_position=goal2,
    target_robot=target2,
)

env2 = RicochetRobotsEnv(
    fixed_layout=layout2,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    render_mode=RENDER_MODE,
)
env2.reset()
frame2 = env2.render()
if frame2 is not None:
    print(frame2)



# %%

```

```pip-requirements
numpy>=1.26
gymnasium>=0.29
pytest>=8.0
jupyter>=1.0
matplotlib>=3.7
```

```python
#%%
"""
Ricochet Robots - Initial Environment Testing Cells

How to use:
- Run each cell independently in a Jupyter-aware editor (e.g., VS Code) that supports #%% cells.
- Edit parameters in-place and re-run cells to iterate.

This script lets you:
- Create fixed or random boards
- Render ASCII boards
- Step through custom action sequences
- Run the solver and replay its plan
- Do random rollouts for smoke testing
"""

from __future__ import annotations

from typing import Dict, Tuple, List, Optional

import numpy as np

from env.ricochet_env import RicochetRobotsEnv, FixedLayout
from env.ricochet_core import UP, DOWN, LEFT, RIGHT
from env.solver import solve_bfs, solve_astar


#%%
# Configuration: tweak these defaults and re-run this cell
HEIGHT: int = 16
WIDTH: int = 16
NUM_ROBOTS: int = 4
INCLUDE_NOOP: bool = True
OBS_MODE: str = "image"  # "image" or "symbolic"
CHANNELS_FIRST: bool = False
STEP_PENALTY: float = -0.01
NOOP_PENALTY: Optional[float] = None  # None -> use STEP_PENALTY
GOAL_REWARD: float = 1.0
MAX_STEPS: int = 100
RENDER_MODE: Optional[str] = "ascii"  # "ascii", "rgb" or None
SEED: Optional[int] = 123

# When ensuring solvable random boards
ENSURE_SOLVABLE: bool = False
SOLVER_MAX_DEPTH: int = 40
SOLVER_MAX_NODES: int = 40000


#%%
# Helper: build a simple fixed layout you can edit
def make_simple_fixed_layout() -> FixedLayout:
    H, W = HEIGHT, WIDTH
    h_walls = np.zeros((H + 1, W), dtype=bool)
    v_walls = np.zeros((H, W + 1), dtype=bool)
    # Borders
    h_walls[0, :] = True
    h_walls[H, :] = True
    v_walls[:, 0] = True
    v_walls[:, W] = True

    # Example interior walls; edit these
    # Horizontal wall between rows 2-3 at column 3
    if H > 2 and W > 3:
        h_walls[2, 3] = True
    # Vertical wall between cols 1-2 at row 4
    if H > 4 and W > 2:
        v_walls[4 - 1, 2] = True  # note: v_walls shape is (H, W+1)

    # Robot positions; ensure unique cells and inside bounds
    robots: Dict[int, Tuple[int, int]] = {}
    robots[0] = (H - 2, 1)
    if NUM_ROBOTS >= 2:
        robots[1] = (1, W - 2)
    if NUM_ROBOTS >= 3:
        robots[2] = (H // 2, W // 2)

    goal: Tuple[int, int] = (1, 1)
    target_robot: int = 0

    return FixedLayout(
        height=H,
        width=W,
        h_walls=h_walls,
        v_walls=v_walls,
        robot_positions=robots,
        goal_position=goal,
        target_robot=target_robot,
    )


#%%
# Create an environment (choose fixed_layout or random with/without ensure_solvable)
USE_FIXED: bool = False

fixed_layout: Optional[FixedLayout] = make_simple_fixed_layout() if USE_FIXED else None

env = RicochetRobotsEnv(
    height=HEIGHT,
    width=WIDTH,
    num_robots=NUM_ROBOTS,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    noop_penalty=NOOP_PENALTY,
    max_steps=MAX_STEPS,
    fixed_layout=fixed_layout,
    seed=SEED,
    ensure_solvable=ENSURE_SOLVABLE,
    solver_max_depth=SOLVER_MAX_DEPTH,
    solver_max_nodes=SOLVER_MAX_NODES,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    channels_first=CHANNELS_FIRST,
    render_mode=RENDER_MODE,
)
obs, info = env.reset()
print("Environment reset. Info:", info)
frame = env.render()
if RENDER_MODE == "ascii" and frame is not None:
    print(frame)
elif RENDER_MODE == "rgb" and frame is not None:
    try:
        import matplotlib.pyplot as plt  # type: ignore
        plt.figure(figsize=(6, 6))
        plt.imshow(frame)
        plt.title("Ricochet Robots - RGB Render")
        plt.axis("off")
        plt.show()
    except Exception as e:
        print("matplotlib not available to display RGB frame; shape:", getattr(frame, "shape", None))


#%%
# Convenience: list action encoding and simple helpers
def encode_action(robot_id: int, direction: int) -> int:
    return robot_id * 4 + direction


DIRS = {"u": UP, "d": DOWN, "l": LEFT, "r": RIGHT}
DIRS_INVERSE = {v: k for k, v in DIRS.items()}
print("Action encoding: action = robot_id * 4 + direction (u=0,d=1,l=2,r=3), noop is last if enabled.")


#%%
# Step through a custom action sequence you edit here
# Each action is a tuple: (robot_id, direction), where direction in {UP, DOWN, LEFT, RIGHT}
custom_actions: List[Tuple[int, int]] = [
    (0, UP),
    (0, LEFT),
]

terminated_any = False
truncated_any = False
total_reward = 0.0

for rid, d in custom_actions:
    a = encode_action(rid, d)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"reward": reward, "terminated": terminated, "truncated": truncated, "info": step_info})
    terminated_any = terminated_any or terminated
    truncated_any = truncated_any or truncated
    if terminated or truncated:
        break

print(f"Cumulative reward: {total_reward:.3f}")


#%%
# Run solver on current board and replay its plan (BFS)
solution = solve_bfs(env._board, max_depth=SOLVER_MAX_DEPTH, max_nodes=SOLVER_MAX_NODES)  # type: ignore[attr-defined]
if solution is None:
    print("Solver did not find a plan within limits.")
else:
    print(f"BFS plan length: {len(solution)} actions")
    # Replay from a fresh reset to ensure matching transitions
    env.reset()
    total_reward = 0.0
    for rid, d in solution:
        a = encode_action(rid, d)
        obs, reward, terminated, truncated, step_info = env.step(a)
        total_reward += reward
        frame = env.render()
        if RENDER_MODE == "ascii" and frame is not None:
            print(frame)
        print({"move": (rid, d), "reward": reward, "terminated": terminated, "truncated": truncated})
        if terminated or truncated:
            break
    print(f"Cumulative reward following solver plan: {total_reward:.3f}")




#%%
# Alternative: A* with selectable heuristic
H_MODE = "admissible_zero"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
H_MODE = "admissible_one"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
#Time how long it takes to solve 1000 times
import time
start_time = time.time()
for i in range(1):
    env.reset()
    frame = env.render()
    if RENDER_MODE == "ascii":
        print(frame)
    astar_sol = solve_astar(env._board, max_depth=200, max_nodes=100000, h_mode=H_MODE)  # type: ignore[attr-defined]
end_time = time.time()
print(f"Time taken: {end_time - start_time} seconds")
if astar_sol is None:
    print("A* did not find a plan within limits.")
else:
    print(f"A* plan length: {len(astar_sol)} (mode={H_MODE})")
# Print the moves in human readable format
for rid, d in astar_sol:
    print(f"Move: {rid}, Direction: {DIRS_INVERSE[d]}")
print(f"Solve length: {len(astar_sol)}")


#%%
# Random rollout for smoke testing
import random

env.reset()
steps = 20
total_reward = 0.0
for t in range(steps):
    a = random.randrange(env.action_space.n)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"t": t + 1, "a": a, "reward": reward, "terminated": terminated, "truncated": truncated})
    if terminated or truncated:
        break
print(f"Random rollout cumulative reward: {total_reward:.3f}")


#%%
# Inspect observation format and channel names (image mode) or vector (symbolic)
if OBS_MODE == "image":
    print("Image observation shape:", obs.shape)
    if hasattr(env, "channel_names"):
        print("Channels:", env.channel_names)
        # Show which cells are occupied by each robot channel
        if not CHANNELS_FIRST:
            base = 6
            for rid in range(NUM_ROBOTS):
                ch = base + rid
                count = int(np.count_nonzero(obs[:, :, ch]))
                print(f"robot_{rid} nonzeros:", count)
else:
    print("Symbolic observation vector length:", obs.shape)
    print("obs:", obs)


#%%
# Build a custom layout from scratch (advanced):
# - Edit the arrays h_walls and v_walls to draw edge walls.
# - Set robots and goal, then rebuild env with this layout.
H2, W2 = HEIGHT, WIDTH
h_walls2 = np.zeros((H2 + 1, W2), dtype=bool)
v_walls2 = np.zeros((H2, W2 + 1), dtype=bool)
# Borders
h_walls2[0, :] = True
h_walls2[H2, :] = True
v_walls2[:, 0] = True
v_walls2[:, W2] = True

# Example interior: make a small room top-left
if H2 > 3 and W2 > 3:
    h_walls2[1, 1] = True
    h_walls2[1, 2] = True
    v_walls2[1, 1] = True

robots2: Dict[int, Tuple[int, int]] = {i: (i % H2, (i * 2) % W2) for i in range(NUM_ROBOTS)}
goal2: Tuple[int, int] = (H2 - 2, W2 - 2)
target2: int = 0

layout2 = FixedLayout(
    height=H2,
    width=W2,
    h_walls=h_walls2,
    v_walls=v_walls2,
    robot_positions=robots2,
    goal_position=goal2,
    target_robot=target2,
)

env2 = RicochetRobotsEnv(
    fixed_layout=layout2,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    render_mode=RENDER_MODE,
)
env2.reset()
frame2 = env2.render()
if frame2 is not None:
    print(frame2)



# %%

```

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii", "rgb"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
        # RGB render configuration
        render_rgb_config: Optional[Dict[str, object]] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        # RGB render defaults
        self._render_rgb_cfg: Dict[str, object] = {
            "cell_size": 20,
            "grid_color": (200, 200, 200),
            "grid_thickness": 1,
            "wall_color": (0, 0, 0),
            "wall_thickness": 3,
            "robot_colors": [
                (220, 50, 50),     # red
                (50, 120, 220),    # blue
                (50, 180, 80),     # green
                (230, 200, 40),    # yellow
                (180, 80, 180),    # purple (extra if more robots)
            ],
            "circle_fill": True,
            "circle_radius_frac": 0.35,
            "target_dark_factor": 0.6,
            "star_thickness": 2,
        }
        if render_rgb_config is not None:
            self._render_rgb_cfg.update(render_rgb_config)

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        # Preserve a base seed to enforce deterministic resets when no new seed is provided
        self._base_seed: Optional[int] = int(seed) if seed is not None else self._episode_seed
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
            self._base_seed = int(self._episode_seed) if self._episode_seed is not None else None
        else:
            # Re-seed with base seed so that resets are deterministic when no new seed is provided
            if self._base_seed is not None:
                try:
                    self.np_random, used_seed = _seeding.np_random(self._base_seed)  # type: ignore[name-defined]
                    self._episode_seed = int(used_seed) if used_seed is not None else int(self._base_seed)
                except NameError:
                    self.np_random = np.random.default_rng(self._base_seed)
                    self._episode_seed = int(self._base_seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode=="rgb": returns an (H_px, W_px, 3) uint8 array.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self._board is None:
            return "" if self.render_mode == "ascii" else None
        if self.render_mode == "ascii":
            from .ricochet_core import render_ascii  # local import to avoid circulars in lints
            return render_ascii(self._board)
        if self.render_mode == "rgb":
            return self._render_rgb(self._board)
        if self._board is None:
            return ""
        raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Disallow juts adjacent to board corners along top/bottom: c must not be 1 or w-1
                    if c in (1, w - 1):
                        continue
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Disallow juts adjacent to board corners along left/right: r must not be 1 or h-1
                    if r in (1, h - 1):
                        continue
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall

    # Public accessor for current board (read-only clone)
    def get_board(self) -> Board:
        if self._board is None:
            raise RuntimeError("Environment not initialized. Call reset() first.")
        return self._board.clone()

    def _render_rgb(self, board: Board) -> np.ndarray:
        # Extract config
        cfg = self._render_rgb_cfg
        cell_size = int(cfg["cell_size"])  # pixels
        grid_color = tuple(int(x) for x in cfg["grid_color"])  # type: ignore[index]
        grid_th = int(cfg["grid_thickness"])  # px
        wall_color = tuple(int(x) for x in cfg["wall_color"])  # type: ignore[index]
        wall_th = int(cfg["wall_thickness"])  # px
        robot_colors: List[Tuple[int, int, int]] = [tuple(int(a) for a in t) for t in cfg["robot_colors"]]  # type: ignore[index]
        circle_fill: bool = bool(cfg["circle_fill"])  # type: ignore[index]
        circle_r_frac: float = float(cfg["circle_radius_frac"])  # type: ignore[index]
        target_dark_factor: float = float(cfg["target_dark_factor"])  # type: ignore[index]
        star_th: int = int(cfg["star_thickness"])  # type: ignore[index]

        H, W = board.height, board.width
        H_px, W_px = H * cell_size, W * cell_size
        img = np.ones((H_px, W_px, 3), dtype=np.uint8) * 255

        # Helpers to draw
        def draw_hline(y: int, x0: int, x1: int, color: Tuple[int, int, int], thickness: int) -> None:
            y0 = max(0, y - thickness // 2)
            y1 = min(H_px, y + (thickness - thickness // 2))
            x0c = max(0, min(x0, x1))
            x1c = min(W_px, max(x0, x1))
            img[y0:y1, x0c:x1c] = color

        def draw_vline(x: int, y0: int, y1: int, color: Tuple[int, int, int], thickness: int) -> None:
            x0 = max(0, x - thickness // 2)
            x1 = min(W_px, x + (thickness - thickness // 2))
            y0c = max(0, min(y0, y1))
            y1c = min(H_px, max(y0, y1))
            img[y0c:y1c, x0:x1] = color

        def draw_circle(cx: float, cy: float, radius: float, color: Tuple[int, int, int], fill: bool) -> None:
            # Bounding box
            x0 = int(max(0, np.floor(cx - radius)))
            x1 = int(min(W_px - 1, np.ceil(cx + radius)))
            y0 = int(max(0, np.floor(cy - radius)))
            y1 = int(min(H_px - 1, np.ceil(cy + radius)))
            yy, xx = np.ogrid[y0:y1 + 1, x0:x1 + 1]
            mask = (xx - cx) ** 2 + (yy - cy) ** 2 <= radius ** 2
            if fill:
                img[y0:y1 + 1, x0:x1 + 1][mask] = color
            else:
                # outline 1px
                inner = (xx - cx) ** 2 + (yy - cy) ** 2 <= (radius - 1) ** 2
                ring = np.logical_and(mask, np.logical_not(inner))
                img[y0:y1 + 1, x0:x1 + 1][ring] = color

        def draw_star(cx: float, cy: float, arm_len: float, color: Tuple[int, int, int], thickness: int) -> None:
            # Draw + arms
            draw_hline(int(cy), int(cx - arm_len), int(cx + arm_len), color, thickness)
            draw_vline(int(cx), int(cy - arm_len), int(cy + arm_len), color, thickness)
            # Draw x arms (diagonals) by sampling small line thickness via plotting short lines of squares
            # Approximate diagonals by drawing small rectangles along the diagonal
            steps = int(arm_len)
            for s in range(-steps, steps + 1):
                x = int(cx + s)
                y1 = int(cy + s)
                y2 = int(cy - s)
                y0a = max(0, y1 - thickness // 2)
                y1a = min(H_px, y1 + (thickness - thickness // 2))
                x0a = max(0, x - thickness // 2)
                x1a = min(W_px, x + (thickness - thickness // 2))
                img[y0a:y1a, x0a:x1a] = color
                y0b = max(0, y2 - thickness // 2)
                y1b = min(H_px, y2 + (thickness - thickness // 2))
                img[y0b:y1b, x0a:x1a] = color

        # 1) Draw faint grid lines
        for r in range(H + 1):
            y = int(r * cell_size)
            draw_hline(y, 0, W_px, grid_color, grid_th)
        for c in range(W + 1):
            x = int(c * cell_size)
            draw_vline(x, 0, H_px, grid_color, grid_th)

        # 2) Draw walls as thicker black lines. h_walls[r,c] between rows r-1 and r over cell column c
        for r in range(H + 1):
            for c in range(W):
                if board.h_walls[r, c]:
                    y = int(r * cell_size)
                    x0 = int(c * cell_size)
                    x1 = int((c + 1) * cell_size)
                    draw_hline(y, x0, x1, wall_color, wall_th)
        for r in range(H):
            for c in range(W + 1):
                if board.v_walls[r, c]:
                    x = int(c * cell_size)
                    y0 = int(r * cell_size)
                    y1 = int((r + 1) * cell_size)
                    draw_vline(x, y0, y1, wall_color, wall_th)

        # 3) Draw robots as filled circles
        radius = cell_size * float(circle_r_frac)
        for rid, (rr, cc) in board.robot_positions.items():
            color = robot_colors[rid % len(robot_colors)]
            cy = rr * cell_size + cell_size * 0.5
            cx = cc * cell_size + cell_size * 0.5
            draw_circle(cx, cy, radius, color, circle_fill)

        # 4) Draw target as a star in darker color of target robot
        tr = board.target_robot
        tr_color = robot_colors[tr % len(robot_colors)]
        dark_color = tuple(int(max(0, min(255, target_dark_factor * v))) for v in tr_color)
        gr, gc = board.goal_position
        cy = gr * cell_size + cell_size * 0.5
        cx = gc * cell_size + cell_size * 0.5
        draw_star(cx, cy, arm_len=cell_size * 0.35, color=dark_color, thickness=star_th)

        return img


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

```python
#%%
"""
Ricochet Robots - Initial Environment Testing Cells

How to use:
- Run each cell independently in a Jupyter-aware editor (e.g., VS Code) that supports #%% cells.
- Edit parameters in-place and re-run cells to iterate.

This script lets you:
- Create fixed or random boards
- Render ASCII boards
- Step through custom action sequences
- Run the solver and replay its plan
- Do random rollouts for smoke testing
"""

from __future__ import annotations

from typing import Dict, Tuple, List, Optional

import numpy as np

from env.ricochet_env import RicochetRobotsEnv, FixedLayout
from env.ricochet_core import UP, DOWN, LEFT, RIGHT
from env.solver import solve_bfs, solve_astar


#%%
# Configuration: tweak these defaults and re-run this cell
HEIGHT: int = 16
WIDTH: int = 16
NUM_ROBOTS: int = 4
INCLUDE_NOOP: bool = True
OBS_MODE: str = "image"  # "image" or "symbolic"
CHANNELS_FIRST: bool = False
STEP_PENALTY: float = -0.01
NOOP_PENALTY: Optional[float] = None  # None -> use STEP_PENALTY
GOAL_REWARD: float = 1.0
MAX_STEPS: int = 100
RENDER_MODE: Optional[str] = "ascii"  # "ascii", "rgb" or None
SEED: Optional[int] = 123

# When ensuring solvable random boards
ENSURE_SOLVABLE: bool = False
SOLVER_MAX_DEPTH: int = 40
SOLVER_MAX_NODES: int = 40000


#%%
# Helper: build a simple fixed layout you can edit
def make_simple_fixed_layout() -> FixedLayout:
    H, W = HEIGHT, WIDTH
    h_walls = np.zeros((H + 1, W), dtype=bool)
    v_walls = np.zeros((H, W + 1), dtype=bool)
    # Borders
    h_walls[0, :] = True
    h_walls[H, :] = True
    v_walls[:, 0] = True
    v_walls[:, W] = True

    # Example interior walls; edit these
    # Horizontal wall between rows 2-3 at column 3
    if H > 2 and W > 3:
        h_walls[2, 3] = True
    # Vertical wall between cols 1-2 at row 4
    if H > 4 and W > 2:
        v_walls[4 - 1, 2] = True  # note: v_walls shape is (H, W+1)

    # Robot positions; ensure unique cells and inside bounds
    robots: Dict[int, Tuple[int, int]] = {}
    robots[0] = (H - 2, 1)
    if NUM_ROBOTS >= 2:
        robots[1] = (1, W - 2)
    if NUM_ROBOTS >= 3:
        robots[2] = (H // 2, W // 2)

    goal: Tuple[int, int] = (1, 1)
    target_robot: int = 0

    return FixedLayout(
        height=H,
        width=W,
        h_walls=h_walls,
        v_walls=v_walls,
        robot_positions=robots,
        goal_position=goal,
        target_robot=target_robot,
    )


#%%
# Create an environment (choose fixed_layout or random with/without ensure_solvable)
USE_FIXED: bool = False

fixed_layout: Optional[FixedLayout] = make_simple_fixed_layout() if USE_FIXED else None

env = RicochetRobotsEnv(
    height=HEIGHT,
    width=WIDTH,
    num_robots=NUM_ROBOTS,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    noop_penalty=NOOP_PENALTY,
    max_steps=MAX_STEPS,
    fixed_layout=fixed_layout,
    seed=SEED,
    ensure_solvable=ENSURE_SOLVABLE,
    solver_max_depth=SOLVER_MAX_DEPTH,
    solver_max_nodes=SOLVER_MAX_NODES,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    channels_first=CHANNELS_FIRST,
    render_mode=RENDER_MODE,
)
obs, info = env.reset()
print("Environment reset. Info:", info)
frame = env.render()
if RENDER_MODE == "ascii" and frame is not None:
    print(frame)
elif RENDER_MODE == "rgb" and frame is not None:
    try:
        import matplotlib.pyplot as plt  # type: ignore
        plt.figure(figsize=(6, 6))
        plt.imshow(frame)
        plt.title("Ricochet Robots - RGB Render")
        plt.axis("off")
        plt.show()
    except ImportError:
        print("matplotlib not available to display RGB frame; shape:", getattr(frame, "shape", None))


#%%
# Convenience: list action encoding and simple helpers
def encode_action(robot_id: int, direction: int) -> int:
    return robot_id * 4 + direction


DIRS = {"u": UP, "d": DOWN, "l": LEFT, "r": RIGHT}
DIRS_INVERSE = {v: k for k, v in DIRS.items()}
print("Action encoding: action = robot_id * 4 + direction (u=0,d=1,l=2,r=3), noop is last if enabled.")


#%%
# Step through a custom action sequence you edit here
# Each action is a tuple: (robot_id, direction), where direction in {UP, DOWN, LEFT, RIGHT}
custom_actions: List[Tuple[int, int]] = [
    (0, UP),
    (0, LEFT),
]

terminated_any = False
truncated_any = False
total_reward = 0.0

for rid, d in custom_actions:
    a = encode_action(rid, d)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"reward": reward, "terminated": terminated, "truncated": truncated, "info": step_info})
    terminated_any = terminated_any or terminated
    truncated_any = truncated_any or truncated
    if terminated or truncated:
        break

print(f"Cumulative reward: {total_reward:.3f}")


#%%
# Run solver on current board and replay its plan (BFS)
solution = solve_bfs(env.get_board(), max_depth=SOLVER_MAX_DEPTH, max_nodes=SOLVER_MAX_NODES)
if solution is None:
    print("Solver did not find a plan within limits.")
else:
    print(f"BFS plan length: {len(solution)} actions")
    # Replay from a fresh reset to ensure matching transitions
    env.reset()
    total_reward = 0.0
    for rid, d in solution:
        a = encode_action(rid, d)
        obs, reward, terminated, truncated, step_info = env.step(a)
        total_reward += reward
        frame = env.render()
        if RENDER_MODE == "ascii" and frame is not None:
            print(frame)
        print({"move": (rid, d), "reward": reward, "terminated": terminated, "truncated": truncated})
        if terminated or truncated:
            break
    print(f"Cumulative reward following solver plan: {total_reward:.3f}")




#%%
# Alternative: A* with selectable heuristic
H_MODE = "admissible_zero"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
H_MODE = "admissible_one"  # one of: "admissible_zero", "admissible_one", "manhattan_cells"
#Time how long it takes to solve 1000 times
import time
start_time = time.time()
for i in range(1):
    env.reset()
    frame = env.render()
    if RENDER_MODE == "ascii":
        print(frame)
    astar_sol = solve_astar(env.get_board(), max_depth=200, max_nodes=100000, h_mode=H_MODE)
end_time = time.time()
print(f"Time taken: {end_time - start_time} seconds")
if astar_sol is None:
    print("A* did not find a plan within limits.")
else:
    print(f"A* plan length: {len(astar_sol)} (mode={H_MODE})")
# Print the moves in human readable format
for rid, d in astar_sol:
    print(f"Move: {rid}, Direction: {DIRS_INVERSE[d]}")
print(f"Solve length: {len(astar_sol)}")


#%%
# Random rollout for smoke testing
import random

env.reset()
steps = 20
total_reward = 0.0
for t in range(steps):
    a = random.randrange(env.action_space.n)
    obs, reward, terminated, truncated, step_info = env.step(a)
    total_reward += reward
    frame = env.render()
    if RENDER_MODE == "ascii" and frame is not None:
        print(frame)
    print({"t": t + 1, "a": a, "reward": reward, "terminated": terminated, "truncated": truncated})
    if terminated or truncated:
        break
print(f"Random rollout cumulative reward: {total_reward:.3f}")


#%%
# Inspect observation format and channel names (image mode) or vector (symbolic)
if OBS_MODE == "image":
    print("Image observation shape:", obs.shape)
    if hasattr(env, "channel_names"):
        print("Channels:", env.channel_names)
        # Show which cells are occupied by each robot channel
        if not CHANNELS_FIRST:
            base = 6
            for rid in range(NUM_ROBOTS):
                ch = base + rid
                count = int(np.count_nonzero(obs[:, :, ch]))
                print(f"robot_{rid} nonzeros:", count)
else:
    print("Symbolic observation vector length:", obs.shape)
    print("obs:", obs)


#%%
# Build a custom layout from scratch (advanced):
# - Edit the arrays h_walls and v_walls to draw edge walls.
# - Set robots and goal, then rebuild env with this layout.
H2, W2 = HEIGHT, WIDTH
h_walls2 = np.zeros((H2 + 1, W2), dtype=bool)
v_walls2 = np.zeros((H2, W2 + 1), dtype=bool)
# Borders
h_walls2[0, :] = True
h_walls2[H2, :] = True
v_walls2[:, 0] = True
v_walls2[:, W2] = True

# Example interior: make a small room top-left
if H2 > 3 and W2 > 3:
    h_walls2[1, 1] = True
    h_walls2[1, 2] = True
    v_walls2[1, 1] = True

robots2: Dict[int, Tuple[int, int]] = {i: (i % H2, (i * 2) % W2) for i in range(NUM_ROBOTS)}
goal2: Tuple[int, int] = (H2 - 2, W2 - 2)
target2: int = 0

layout2 = FixedLayout(
    height=H2,
    width=W2,
    h_walls=h_walls2,
    v_walls=v_walls2,
    robot_positions=robots2,
    goal_position=goal2,
    target_robot=target2,
)

env2 = RicochetRobotsEnv(
    fixed_layout=layout2,
    include_noop=INCLUDE_NOOP,
    step_penalty=STEP_PENALTY,
    goal_reward=GOAL_REWARD,
    obs_mode=OBS_MODE,  # type: ignore[arg-type]
    render_mode=RENDER_MODE,
)
env2.reset()
frame2 = env2.render()
if frame2 is not None:
    print(frame2)



# %%

```

- Added RGB rendering to `RicochetRobotsEnv`:
  - New `render_mode="rgb"` returns a uint8 HxWx3 image.
  - Configurable via `render_rgb_config` with defaults:
    - Grid: faint gray lines
    - Walls: thicker black lines
    - Robots: filled circles in red/blue/green/yellow (extensible list)
    - Target: darker-colored star of the target robots color
  - New helper `get_board()` returns a read-only clone for external use.

- Updated `initial_testing_cells.py`:
  - Supports `RENDER_MODE="rgb"` and displays via matplotlib if available (graceful fallback otherwise).
  - Solver examples now use `env.get_board()` instead of accessing `_board`.

You can try the RGB render by setting `RENDER_MODE = "rgb"` in `initial_testing_cells.py`.

---

**User**

Amazing work, thanks! Another change I forgot to mention: the target should always be placed inside a central-L square (again, this should be random but respect seed determinism)

---

**Cursor**

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii", "rgb"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
        # RGB render configuration
        render_rgb_config: Optional[Dict[str, object]] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        # RGB render defaults
        self._render_rgb_cfg: Dict[str, object] = {
            "cell_size": 20,
            "grid_color": (200, 200, 200),
            "grid_thickness": 1,
            "wall_color": (0, 0, 0),
            "wall_thickness": 3,
            "robot_colors": [
                (220, 50, 50),     # red
                (50, 120, 220),    # blue
                (50, 180, 80),     # green
                (230, 200, 40),    # yellow
                (180, 80, 180),    # purple (extra if more robots)
            ],
            "circle_fill": True,
            "circle_radius_frac": 0.35,
            "target_dark_factor": 0.6,
            "star_thickness": 2,
        }
        if render_rgb_config is not None:
            self._render_rgb_cfg.update(render_rgb_config)

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        # Preserve a base seed to enforce deterministic resets when no new seed is provided
        self._base_seed: Optional[int] = int(seed) if seed is not None else self._episode_seed
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
            self._base_seed = int(self._episode_seed) if self._episode_seed is not None else None
        else:
            # Re-seed with base seed so that resets are deterministic when no new seed is provided
            if self._base_seed is not None:
                try:
                    self.np_random, used_seed = _seeding.np_random(self._base_seed)  # type: ignore[name-defined]
                    self._episode_seed = int(used_seed) if used_seed is not None else int(self._base_seed)
                except NameError:
                    self.np_random = np.random.default_rng(self._base_seed)
                    self._episode_seed = int(self._base_seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode=="rgb": returns an (H_px, W_px, 3) uint8 array.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self._board is None:
            return "" if self.render_mode == "ascii" else None
        if self.render_mode == "ascii":
            from .ricochet_core import render_ascii  # local import to avoid circulars in lints
            return render_ascii(self._board)
        if self.render_mode == "rgb":
            return self._render_rgb(self._board)
        if self._board is None:
            return ""
        raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid-1, mid - 1] = True
            h_walls[mid-1, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid-1] = True
            v_walls[mid, mid-1] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def cell_has_nonboundary_wall(r: int, c: int) -> bool:
            # top edge is h_walls[r, c] (non-boundary if r > 0)
            if r > 0 and h_walls[r, c]:
                return True
            # bottom edge is h_walls[r+1, c] (non-boundary if r+1 < h)
            if r + 1 < h and h_walls[r + 1, c]:
                return True
            # left edge is v_walls[r, c] (non-boundary if c > 0)
            if c > 0 and v_walls[r, c]:
                return True
            # right edge is v_walls[r, c+1] (non-boundary if c+1 < w)
            if c + 1 < w and v_walls[r, c + 1]:
                return True
            return False

        def neighbors4(r: int, c: int) -> List[Tuple[int, int]]:
            nbrs: List[Tuple[int, int]] = []
            if r - 1 >= 0:
                nbrs.append((r - 1, c))
            if r + 1 < h:
                nbrs.append((r + 1, c))
            if c - 1 >= 0:
                nbrs.append((r, c - 1))
            if c + 1 < w:
                nbrs.append((r, c + 1))
            return nbrs

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Disallow juts adjacent to board corners along top/bottom: c must not be 1 or w-1
                    if c in (1, w - 1):
                        continue
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        # Determine the adjacent interior cell around which this edge-T is formed
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        # Enforce: no neighbor of a walled cell may be a structure center
                        # i.e., candidate center adj_cell must not have neighbors with non-boundary walls
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            v_walls[r0, c] = True
                            used_interior_v.add((r0, c))
                            reserve_cell(adj_cell)
                            return True
                else:
                    r, c0 = pos
                    # Disallow juts adjacent to board corners along left/right: r must not be 1 or h-1
                    if r in (1, h - 1):
                        continue
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        blocked = any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(adj_cell[0], adj_cell[1]))
                        if not blocked and (0 <= adj_cell[0] < h and 0 <= adj_cell[1] < w) and adj_cell not in reserved_cells:
                            h_walls[r, c0] = True
                            used_interior_h.add((r, c0))
                            reserve_cell(adj_cell)
                            return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        central_l_centers: List[Tuple[int, int]] = []

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    # Enforce: no neighbor of a walled cell may be a structure center
                    if any(cell_has_nonboundary_wall(rr, cc) for rr, cc in neighbors4(r, c)):
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness and record as a central-L center
                reserve_cell((r, c))
                central_l_centers.append((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal inside a central-L square (randomly among placed central-L centers), excluding central forbidden block
        central_set = set((r, c) for r in central_rows for c in central_cols)
        candidates_goal = [rc for rc in central_l_centers if rc not in central_set]
        if not candidates_goal:
            # Fallback: if for some reason no central-L could be placed, select any non-central cell deterministically
            candidates_goal = [(r, c) for r in range(h) for c in range(w) if (r, c) not in central_set]
        idx = int(self.np_random.integers(0, len(candidates_goal)))
        goal = candidates_goal[idx]

        # Place robots in free cells excluding central block and the goal cell
        free_cells: List[Tuple[int, int]] = []
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set or (r, c) == goal:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall

    # Public accessor for current board (read-only clone)
    def get_board(self) -> Board:
        if self._board is None:
            raise RuntimeError("Environment not initialized. Call reset() first.")
        return self._board.clone()

    def _render_rgb(self, board: Board) -> np.ndarray:
        # Extract config
        cfg = self._render_rgb_cfg
        cell_size = int(cfg["cell_size"])  # pixels
        grid_color = tuple(int(x) for x in cfg["grid_color"])  # type: ignore[index]
        grid_th = int(cfg["grid_thickness"])  # px
        wall_color = tuple(int(x) for x in cfg["wall_color"])  # type: ignore[index]
        wall_th = int(cfg["wall_thickness"])  # px
        robot_colors: List[Tuple[int, int, int]] = [tuple(int(a) for a in t) for t in cfg["robot_colors"]]  # type: ignore[index]
        circle_fill: bool = bool(cfg["circle_fill"])  # type: ignore[index]
        circle_r_frac: float = float(cfg["circle_radius_frac"])  # type: ignore[index]
        target_dark_factor: float = float(cfg["target_dark_factor"])  # type: ignore[index]
        star_th: int = int(cfg["star_thickness"])  # type: ignore[index]

        H, W = board.height, board.width
        H_px, W_px = H * cell_size, W * cell_size
        img = np.ones((H_px, W_px, 3), dtype=np.uint8) * 255

        # Helpers to draw
        def draw_hline(y: int, x0: int, x1: int, color: Tuple[int, int, int], thickness: int) -> None:
            y0 = max(0, y - thickness // 2)
            y1 = min(H_px, y + (thickness - thickness // 2))
            x0c = max(0, min(x0, x1))
            x1c = min(W_px, max(x0, x1))
            img[y0:y1, x0c:x1c] = color

        def draw_vline(x: int, y0: int, y1: int, color: Tuple[int, int, int], thickness: int) -> None:
            x0 = max(0, x - thickness // 2)
            x1 = min(W_px, x + (thickness - thickness // 2))
            y0c = max(0, min(y0, y1))
            y1c = min(H_px, max(y0, y1))
            img[y0c:y1c, x0:x1] = color

        def draw_circle(cx: float, cy: float, radius: float, color: Tuple[int, int, int], fill: bool) -> None:
            # Bounding box
            x0 = int(max(0, np.floor(cx - radius)))
            x1 = int(min(W_px - 1, np.ceil(cx + radius)))
            y0 = int(max(0, np.floor(cy - radius)))
            y1 = int(min(H_px - 1, np.ceil(cy + radius)))
            yy, xx = np.ogrid[y0:y1 + 1, x0:x1 + 1]
            mask = (xx - cx) ** 2 + (yy - cy) ** 2 <= radius ** 2
            if fill:
                img[y0:y1 + 1, x0:x1 + 1][mask] = color
            else:
                # outline 1px
                inner = (xx - cx) ** 2 + (yy - cy) ** 2 <= (radius - 1) ** 2
                ring = np.logical_and(mask, np.logical_not(inner))
                img[y0:y1 + 1, x0:x1 + 1][ring] = color

        def draw_star(cx: float, cy: float, arm_len: float, color: Tuple[int, int, int], thickness: int) -> None:
            # Draw + arms
            draw_hline(int(cy), int(cx - arm_len), int(cx + arm_len), color, thickness)
            draw_vline(int(cx), int(cy - arm_len), int(cy + arm_len), color, thickness)
            # Draw x arms (diagonals) by sampling small line thickness via plotting short lines of squares
            # Approximate diagonals by drawing small rectangles along the diagonal
            steps = int(arm_len)
            for s in range(-steps, steps + 1):
                x = int(cx + s)
                y1 = int(cy + s)
                y2 = int(cy - s)
                y0a = max(0, y1 - thickness // 2)
                y1a = min(H_px, y1 + (thickness - thickness // 2))
                x0a = max(0, x - thickness // 2)
                x1a = min(W_px, x + (thickness - thickness // 2))
                img[y0a:y1a, x0a:x1a] = color
                y0b = max(0, y2 - thickness // 2)
                y1b = min(H_px, y2 + (thickness - thickness // 2))
                img[y0b:y1b, x0a:x1a] = color

        # 1) Draw faint grid lines
        for r in range(H + 1):
            y = int(r * cell_size)
            draw_hline(y, 0, W_px, grid_color, grid_th)
        for c in range(W + 1):
            x = int(c * cell_size)
            draw_vline(x, 0, H_px, grid_color, grid_th)

        # 2) Draw walls as thicker black lines. h_walls[r,c] between rows r-1 and r over cell column c
        for r in range(H + 1):
            for c in range(W):
                if board.h_walls[r, c]:
                    y = int(r * cell_size)
                    x0 = int(c * cell_size)
                    x1 = int((c + 1) * cell_size)
                    draw_hline(y, x0, x1, wall_color, wall_th)
        for r in range(H):
            for c in range(W + 1):
                if board.v_walls[r, c]:
                    x = int(c * cell_size)
                    y0 = int(r * cell_size)
                    y1 = int((r + 1) * cell_size)
                    draw_vline(x, y0, y1, wall_color, wall_th)

        # 3) Draw robots as filled circles
        radius = cell_size * float(circle_r_frac)
        for rid, (rr, cc) in board.robot_positions.items():
            color = robot_colors[rid % len(robot_colors)]
            cy = rr * cell_size + cell_size * 0.5
            cx = cc * cell_size + cell_size * 0.5
            draw_circle(cx, cy, radius, color, circle_fill)

        # 4) Draw target as a star in darker color of target robot
        tr = board.target_robot
        tr_color = robot_colors[tr % len(robot_colors)]
        dark_color = tuple(int(max(0, min(255, target_dark_factor * v))) for v in tr_color)
        gr, gc = board.goal_position
        cy = gr * cell_size + cell_size * 0.5
        cx = gc * cell_size + cell_size * 0.5
        draw_star(cx, cy, arm_len=cell_size * 0.35, color=dark_color, thickness=star_th)

        return img


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Done. The generator now records all central-L centers and places the goal uniformly at random among them (excluding the forbidden central block), using `self.np_random` so its deterministic under the seed. If no central-Ls were placed (edge case), it falls back to any non-central cell.

- Goal is chosen before robots; robots are sampled from remaining free cells.
- Lints clean.

---

**User**

This is all amazing work, well done. You're now going to take a break, so it's time to make notes for yourself and/or a colleague who will pick this up at a later stage. Please can you detail your work in the files in the folder ProgressNotes? You should include anything you think is useful context for a colleague who may be picking this work up later on, such as what you have done, things you think remain, any useful explanations or insights from our conversation or your feedback, etc. 

---

**Cursor**

I'll add concise status updates and context to the ProgressNotes files, summarizing implemented changes, rationale, and next steps for colleagues.

```markdown
## Environment Status (Stage 1.4)

Summary of changes implemented during initial testing and spec enforcement:

- Constructive board generator implemented in `env/ricochet_env.py` to satisfy `env/WallSpecifications.md` without generate-and-reject.
  - Boards enforced to be square and include a forbidden central block (1x1 for odd sizes, 2x2 for even) with walls surrounding it.
  - Two structure types per quadrant:
    - Edge-T: single interior edge jut off a border, avoiding corners and adhering to adjacency constraints.
    - Central-L: two interior edges forming an L around a cell, with balanced orientations within each quadrant.
  - No cell can host more than one structure. Structures do not contact each other or the central/border walls except where permitted by spec.
  - New configurable counts per quadrant: `edge_t_per_quadrant` and `central_l_per_quadrant` (defaults: 2 if side < 10 else 4).

- Additional constraints enforced:
  - Robots and goal are never placed within the forbidden central block.
  - Central-L cannot be placed around edge cells.
  - If a cell has a non-boundary wall, none of its 4-neighbors can be the center of an Edge-T or a Central-L.
  - Edge-T juts cannot be adjacent to corners (e.g., top/bottom juts skip c in {1, w-1}; left/right juts skip r in {1, h-1}).
  - Target goal must be placed inside a Central-L cell (uniformly at random among eligible centers; deterministic under seed). Fallback to non-central cells only if no Central-Ls were placed (edge case).

- Determinism and seeding:
  - The env now stores a base seed on init and re-seeds RNG on every `reset()` when no new seed is provided. `reset(seed=...)` updates the base seed. This ensures identical boards across resets under the same seed.

- Rendering:
  - New `render_mode="rgb"` returns an RGB uint8 array. Defaults are configurable via `render_rgb_config` (grid lines faint gray, walls thick black, robots colored circles, target as darker star of target robot color).
  - Kept existing `render_mode="ascii"`.

- Public accessors:
  - Added `get_board()` returning a clone of the current `Board` for safe external use (tests/solvers).

Compatibility notes:

- Existing tests that use `FixedLayout` continue to pass (constructive generator is bypassed for fixed layouts).
- Observation spaces unchanged.
- Some prior direct uses of `_board` in the testing script were replaced with `get_board()` to avoid accessing protected members.

# Environment Status (Step 1.1)

Implemented a canonical Ricochet Robots environment with edge-wall mechanics and Gymnasium-style API.

## Core features
- Canonical edge walls: `h_walls (H+1,W)`, `v_walls (H,W+1)` with borders; movement uses edge collisions and robot blocking.
- Sliding dynamics: robots move until blocked by an edge-wall or another robot.
- Termination: episode ends when target robot reaches goal; `terminated` and `truncated` are mutually exclusive.
- Actions: Discrete `num_robots*4 (+1 if noop)` encoded as `(robot_id, direction)`.
- Observation modes:
  - Image: channels-first or channels-last
    - Channels: 4 directional wall planes (up, down, left, right), 1 goal plane, 1 target-robot mask plane, then one plane per robot.
  - Symbolic: vector `[goal_r, goal_c, target_id_one_hot(num_robots), robots_flat(num_robots*2)]`.
- No-op support: separate `noop_penalty` vs `step_penalty`.
- Deterministic expansion/testing: fixed layouts via `FixedLayout`.

## Random generation
- Generates bordered grids, adds interior edge-walls, places robots and goal at free cells.
- `ensure_solvable=True` uses the solver to filter boards; info includes `optimal_length` and `solver_limits`.
  - Note: solver returning None during generation may be due to cutoffs (depth/nodes), not true unsolvability.

## API details
- `RicochetRobotsEnv.reset(ensure_solvable=True)` returns `info` with:
  - `level_solvable` (bool): True when solvability was enforced this episode; False otherwise.
  - `ensure_solvable_enabled` (bool): whether enforcement was enabled for this episode.
  - `optimal_length`: minimal moves from solver (when enabled).
  - `solver_limits`: dict with `max_depth`, `max_nodes` (when enabled).
  - `target_robot`: index of target robot.
  - `episode_seed`: resolved seed for this episode.
  - `channel_names` (image mode): ordered channel labels for logging.

## Rendering
- ASCII renderer shows edge walls and robots; useful for QA and CLI demo.
- Gymnasium-compliant: `render_mode="ascii"` returns a string. Unsupported modes raise a clear error. `render_mode=None` returns `None`.

## Seeding and determinism
- Uses Gymnasium seeding (`self.np_random` via `gymnasium.utils.seeding.np_random`).
- Deterministic given a seed. With `ensure_solvable=True`, retries depend only on RNG draws; the solver is deterministic.

## Tests (env)
- Sliding and stopping on walls and robots.
- Goal termination and reward.
- Multi-robot blocking and `max_steps` truncation.
- Observation variants: channel order and symbolic layout.
- No-op semantics: state unchanged, distinct penalty.
- Solvability integration: `optimal_length` reported; actions applied reach goal.

## Performance
- Wall channels are cached on reset and reused each step for image observations.

## Known limitations / notes
- Image wall encoding chooses directional per-cell planes; this exposes canonical geometry directly to CNNs.
- Random generator may create tight alcoves; rely on `ensure_solvable=True` for training or later add density/connectivity controls.
- Internal time limit is enforced by `max_steps`; wrapping additionally with Gyms TimeLimit may duplicate truncation signals unless configured carefully.

```

```markdown
## Solver Status

- Solver implementation (BFS/A*) unchanged; used for validation and optional solvability checks in env.
- `initial_testing_cells.py` examples updated to use `env.get_board()` for read-only access.
- No new constraints added to solver; it should remain consistent with the environments movement rules.

Potential future work:

- Add tests to validate that solver solutions can be replayed in the updated environment with spec-driven walls.
- Optionally enhance solver heuristics aware of structure patterns (not required for current scope).
# Solver Status (Step 1.2)

Two planners are provided: BFS (optimal in moves within limits) and A* (configurable heuristic).

## BFS
- Cost model: one slide = one step. Minimizes number of slides.
- Deterministic neighbor expansion (sorted robot ids).
- Pruning: skip non-moves; optional skip of repeated (robot,direction).
- Metadata: `solve_bfs(return_metadata=True)` or `solve_bfs_with_metadata` returns `SolveResult` with `actions`, `nodes_expanded`, `depth`, `found`.
- Limits: `max_depth` (path-length cutoff), `max_nodes` (expansion cap). Returning `None` (or `found=False`) may indicate cutoffs, not true unsolvability.

## A*
- Heuristic modes:
  - `admissible_zero`: h=0 (optimal, slower).
  - `admissible_one`: h  {0,1} (admissible, slightly more informed).
  - `manhattan_cells`: non-admissible (may be faster but can be suboptimal).
- Metadata: `solve_astar(return_metadata=True)` or `solve_astar_with_metadata` mirrors BFS.

## Helpers
- `apply_actions(board, actions)`: apply a plan to a board.
- `serialize(board)`: visited-state key (robot positions only). Assumes fixed walls/goal/target per search instance; recompute for other boards.

## Usage guidance
- Use BFS or A* with admissible heuristic when you need guaranteed optimal lengths (for curriculum thresholds and evaluation).
- Consider `prioritize_target_first=True` for quicker finds; correctness unchanged.
- If scaling up: represent robot positions as a fixed tuple and share wall arrays to reduce allocations.

## Determinism and env integration
- Both BFS and A* are deterministic given a fixed start board and parameters.
- `ensure_solvable=True` in the env uses BFS to filter boards; the env now reports `level_solvable`, `ensure_solvable_enabled`, and (when enforced) `optimal_length`.

## Tests (solver)
- Optimality on tiny boards (length 1).
- Cutoff behavior (depth=0 -> None).
- Multi-robot prerequisite move.
- A* (admissible) matches BFS optimal plans.
- Zero-length start-on-goal.

## Future extensions
- Add generator utilities to sample boards with `optimal_length <= N` for curriculum.
- Add optional greedy neighbor ordering toward goal delta as a speed-up (correctness unaffected).

```

```markdown
## Next Steps

Recommended follow-ups for Stage 1.4 and beyond:

1) Add unit tests for spec enforcement:
   - Central block placement (odd/even boards).
   - Edge-T and Central-L counts per quadrant with balanced orientations.
   - No Central-L on edge cells.
   - Corner adjacency rule for Edge-T juts.
   - Neighbor-of-walled-cell cannot be a structure center.
   - Goal placed in a Central-L cell; robots/goals never in central forbidden block.
   - Reproducibility: repeated `reset()` with same seed yields identical boards.

2) Visual sanity checks:
   - Extend `initial_testing_cells.py` to save RGB renders to disk for a few seeds and sizes.
   - Optionally add overlays to indicate recognized structures during debugging.

3) Performance:
   - Profile `_generate_random_board` for large boards; consider early pruning if placements struggle due to constraints.
   - If needed, allow retries within a bounded loop to achieve requested per-quadrant counts, with clear info messages.

4) Curriculum ties (later stages):
   - Expose difficulty knobs (e.g., control counts or orientations mix) via env params for training curricula.

5) Documentation:
   - Mirror key rules from `env/WallSpecifications.md` into docstrings of generator helpers for discoverability.
# Next Steps

## Step 2 (Training framework and models)
- Integrate with SB3 PPO/A2C:
  - Wrap env with vectorization; set obs_mode and channel order compatible with policy.
  - Baseline CNN policy first (channels_first recommended), then recurrent policy later.
- Curriculum integration:
  - Use `ensure_solvable=True` and `info["optimal_length"]` to bucket episodes.
  - Optionally build a sampler that targets `optimal_length <= N` for staged difficulty.
- Logging & evaluation:
  - Log `is_success`, `steps`, `optimal_length` (when available), and episode returns.
  - Periodic evaluation using solver for optimality gap on a fixed set.

## Optional solver improvements
- Add a curriculum generator utility: repeatedly sample until a board with `optimal_length <= N` is found; return `(board, length)`.
- Consider BFS parent-pointer reconstruction to count nodes and reduce allocations; return nodes_expanded cleanly.
- Expose a "greedy neighbor ordering" option for speed, without affecting correctness.

## Interpretability scaffolding (Step 5 prep)
- Plan forward hooks in policies to capture activations.
- Define a small dataset writer that records obs, actions, logits, value, hidden states per step for probe training.

## Engineering hygiene & docs
- Add training README section: how to run PPO baseline with vectorized envs; include typical hyperparameters.
- Consider a tiny `train_agent.py` script to smoke test PPO on trivial configs.
- Package the repo (pyproject/SETUP) so users can `pip install -e .` and resolve registration entry point robustly.
- If adding RGB render later, document return type/shape and update metadata.

## Backlog/polish
- Optional: add a flag to normalize symbolic observations to [0,1] to match common pipelines.
- Optional: export typed constants for directions in `ricochet_env` mirroring `ricochet_core` for documentation clarity.
- Optional: expose board-density parameters for random generation (e.g., interior wall count bounds).

```

```markdown
## Decisions and Rationale

1) Constructive generation over rejection sampling:
   - Rationale: Many constraints in `WallSpecifications.md` make naive generate-and-filter expensive. We added structure-aware placement to build valid boards directly while preserving seed determinism.

2) Seed determinism contract (Step 1.3):
   - Decision: Store a base seed at init and reinitialize RNG on each `reset()` when no new seed is passed. This makes repeated resets deterministic under a given seed and updates determinism when a new seed is provided.

3) Structure separation and adjacency rules:
   - Implemented checks that avoid Central-L on edges, avoid corner-adjacent Edge-T juts, and prevent neighbors of walled cells from being structure centers. These ensure cleaner puzzles and avoid overly congested local structures.

4) Goal placement inside Central-L:
   - To focus gameplay around intentionally structured features, the target is now placed in a Central-L cell, randomized under RNG for variety, with a safe fallback.

5) Public `get_board()` accessor:
   - Avoids external code relying on `_board` internals; returns a clone to preserve env invariants.

6) RGB rendering:
   - Added basic but configurable drawer to aid debugging and qualitative checks; kept ASCII for quick console output.

Alternatives considered:
   - Rejection sampling with solver checks was considered but rejected for performance reasons.
   - Storing full placement plans per quadrant was deemed unnecessary; local checks suffice for the current spec.
# Decisions and Rationale

## Canonical edge walls
- We refactored to edge-wall representation (`h_walls`, `v_walls`) to match Ricochet Robots rules and literature, ensuring correct sliding and stopping behavior and comparability.

## Observation encoding
- Image mode includes four directional wall channels so CNNs can directly learn canonical geometry. This is preferable to a single wall mask because directionality matters for planning.
- Target identity exposed via a per-cell target mask. Symbolic mode includes a target one-hot.
- Channel order toggle (channels_first) added for RL-library compatibility.

## No-op action and pacing
- No-op included to allow explicit thinking steps; separate `noop_penalty` enables studying pacing behavior without conflating with move penalty.

## Solver choices
- BFS is the baseline optimal planner in number of slides.
- A* added with selectable heuristic modes: admissible defaults for optimality; non-admissible Manhattan option documented for speed experiments.
- Deterministic neighbor ordering simplifies reproducibility and profiling.

## Env-solvability integration
- `ensure_solvable=True` uses solver filtering; `optimal_length` and solver limits provided in `info` for curriculum.
- `level_solvable` is now a strict boolean with companion `ensure_solvable_enabled` to avoid tri-state ambiguity.

## Testing philosophy
- Tests target both mechanics (movement, stopping, truncation) and solver properties (optimality, cutoff, multi-robot needs), plus observation shapes/semantics and env-solver roundtrips.

## Performance considerations (future)
- Walls are immutable; keep them shared across states. Robot positions can be a small tuple for faster hashing.
- Parent-pointer path reconstruction is used in A*; consider for BFS if we need to reduce allocations and capture metadata more cheaply.

## Gymnasium compliance (Step 1.3)
- Adopted Gymnasium seeding (`self.np_random`), `reset(seed=...) -> (obs, info)`, and five-return `step` signature.
- Added `render_mode` with only `"ascii"` supported; `render()` returns a string frame, matching the configured mode.
- Provided `close()` and legacy `seed()`; invalid actions raise `gymnasium.error.InvalidAction` when available.
- Symbolic observation space bounds are finite and match board indices; image obs are float32 in [0,1].
- Registration helper included; supports `max_episode_steps` but warns about duplicate time limits.

```

```markdown
## Progress Notes Overview

This folder tracks environment and solver progress, decisions, and next steps.

Key files updated for Stage 1.4:

- `env_status.md`: Current environment capabilities, spec-driven generator, determinism, and rendering.
- `solver_status.md`: Solver status and suggested validation tasks.
- `decisions_and_rationale.md`: Why specific implementation choices were made.
- `next_steps.md`: Concrete follow-ups and tests to add.

See `env/WallSpecifications.md` for the authoritative constraints that the generator enforces.
# Progress Notes

This folder captures the current state of Step 1 (environment + solver) and related integration, plus guidance for Step 2.

## Contents
- env_status.md: Summary of the Ricochet Robots environment implementation, observation modes, and design choices.
- solver_status.md: Summary of BFS/A* solvers, heuristics, metadata, and tests.
- next_steps.md: Concrete follow-ups and priorities for the next work session.
- decisions_and_rationale.md: Key decisions, tradeoffs, and reasoning.

```

- I wrote concise notes in `ProgressNotes`:
  - `env_status.md`: what changed in the env, constraints enforced, determinism, and rendering.
  - `solver_status.md`: current solver state and follow-ups.
  - `decisions_and_rationale.md`: key design choices and why.
  - `next_steps.md`: recommended tests and improvements.
  - `README.md`: where to look for status info.

- Everything reflects the spec-driven generator, seed determinism, RGB rendering, and goal-in-central-L change.

