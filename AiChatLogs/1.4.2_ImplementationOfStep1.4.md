# Implement changes for board generation
_Exported on 12/09/2025 at 13:33:37 BST from Cursor (1.4.5)_

---

**User**

You are a language model, working as part of a team to implement a research proposal. Please take the time to read the ResearchPlan.md. 
Your colleagues have implemented steps 1.1 - 1.3 of the plan, and these have been checked and are deemed completed. 
We are now in stage 1.4, the initial testing of the environment, and your job is to assist me in making some changes to the way the environment is generated. 

In particular, we want to make changes to ensure the generated boards satisfy some specifications, as detailed in 'env/WallSpecifications.md'. Any board generated should satisfy these conditions. This should respect reproducability under the same random seed, and should not involve generating and then testing for conditions afterward and accepting/rejecting a board based on this (since there are a lot of conditions, this would take a long time when we need to generate a new board), so it should instead be done in a constructive way.

Please go ahead and implement these changes. If you are uncertain or have questions, you can ask them.

---

**Cursor**

I'll scan the research plan and the environment code, plus the wall specifications, to understand how boards are currently generated and where to integrate constructive constraints. Then I'll update the generator to enforce the specs while preserving seed-based reproducibility.

I'll scan the tests to see how the environment expects board generation to work and to detect any existing references to the specified wall structures, so I can integrate changes without breaking tests.

I'll quickly scan the remaining tests to see any expectations around random board generation, so I can preserve interfaces and not break tests while adding the constructive generator.

I'll implement a constructive board generator in `env/ricochet_env.py` that enforces the wall specifications, add configurable per-quadrant counts with sensible defaults, and ensure robots/goal placement respects the central block. Then I'll run linters on the modified file to catch any issues.

I'll add new parameters and a constructive generator to `env/ricochet_env.py`, replacing `_generate_random_board` to build walls by quadrant (edge-T and central-L), add central forbidden block, then place robots/goal outside it. I'll keep RNG via `self.np_random` for reproducibility. Now I'll make the edits.

I'm going to add new configuration parameters and replace the random board generator with a constructive generator that builds the forbidden central block, per-quadrant edge-T and central-L structures with balanced orientations, and places robots/goal outside the central block while maintaining seed-based reproducibility. Then I'll run a linter check on the modified file.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for name, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for name, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

I updated the generator to construct boards that follow the `WallSpecifications.md` rules with per-quadrant counts and central block constraints, and added configuration options. I'll run a linter on `env/ricochet_env.py` and then mark the completed tasks.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

- I added a constructive generator in `env/ricochet_env.py` that:
  - Enforces square boards and builds the forbidden central block (1x1 for odd, 2x2 for even), and excludes robots/goal from it.
  - Places per-quadrant wall structures: edge-T at borders and central-L inside, using `self.np_random` for reproducibility.
  - Distributes central-L orientations as evenly as possible within each quadrant.
  - Ensures no cell hosts more than one structure.
  - Exposes `edge_t_per_quadrant` and `central_l_per_quadrant` with defaults: 2 if side < 10 else 4.
- I ran lints; fixed a minor warning.

Would you like me to add unit tests to verify these wall-spec constraints and reproducibility under a fixed seed?

---

**User**

I forgot one rule: 
- Central-L structures cannot be around an edge square

---

**Cursor**

I'll update the central-L placement to exclude edge cells explicitly, ensuring no central-L is placed around an edge square. I'll make the change now.

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple, List, Literal, Set

import numpy as np

from .ricochet_core import Board, apply_action, reached_goal

# Provide a runtime gymnasium binding if available, otherwise a minimal fallback
try:  # pragma: no cover
    import importlib
    _gym = importlib.import_module("gymnasium")  # type: ignore
    _spaces = importlib.import_module("gymnasium.spaces")  # type: ignore
    _seeding = importlib.import_module("gymnasium.utils.seeding")  # type: ignore
    _error = importlib.import_module("gymnasium.error")  # type: ignore
    GymEnvBase = _gym.Env  # type: ignore
    spaces = _spaces  # type: ignore
    GymInvalidAction = getattr(_error, "InvalidAction", None)  # type: ignore
except (ModuleNotFoundError, ImportError):  # pragma: no cover
    class GymEnvBase(object):
        pass
    class _SpacesDummy:  # minimal placeholders to satisfy type usage
        class Box:  # type: ignore
            def __init__(self, low=None, high=None, shape=None, dtype=None):
                self.low = low
                self.high = high
                self.shape = shape
                self.dtype = dtype
        class Discrete:  # type: ignore
            def __init__(self, n: int):
                self.n = n
    spaces = _SpacesDummy()  # type: ignore
    GymInvalidAction = None  # type: ignore


@dataclass
class FixedLayout:
    height: int
    width: int
    # Edge walls
    h_walls: np.ndarray  # (H+1, W) bool
    v_walls: np.ndarray  # (H, W+1) bool
    robot_positions: Dict[int, Tuple[int, int]]
    goal_position: Tuple[int, int]
    target_robot: int


ObsMode = Literal["image", "symbolic"]


class RicochetRobotsEnv(GymEnvBase):
    """Ricochet Robots Gymnasium-compatible environment.

    Determinism and seeding:
    - Deterministic given the seed provided to __init__ or reset(seed=...).
    - Randomness flows through self.np_random (Gymnasium seeding utils); the episode's resolved
      seed is exposed via info["episode_seed"].
    - When ensure_solvable=True, the environment may retry board generation; retries do not add
      extra non-determinism beyond RNG draws. The included solver is deterministic.

    Observations:
    - Image mode: float32 in [0,1]. Channels are named by channel_names; note that the target robot
      is represented both by a dedicated mask (index 5) and its robot channel (duplication by design).
    - Symbolic mode: float32 with absolute grid indices (not normalized). Downstream code may wish to
      normalize to [0,1]. The Box low/high reflect board bounds.

    Rendering:
    - Only render_mode="ascii" is implemented and returns a string frame.
    - Other modes are not implemented and will raise a clear error.
    """
    metadata = {"render_modes": ["ascii"], "render_fps": 4}

    def __init__(
        self,
        height: int = 8,
        width: int = 8,
        num_robots: int = 2,
        include_noop: bool = True,
        step_penalty: float = -0.01,
        goal_reward: float = 1.0,
        noop_penalty: Optional[float] = None,
        max_steps: int = 100,
        fixed_layout: Optional[FixedLayout] = None,
        seed: Optional[int] = None,
        ensure_solvable: bool = False,
        solver_max_depth: int = 30,
        solver_max_nodes: int = 20000,
        obs_mode: ObsMode = "image",
        channels_first: bool = False,
        render_mode: Optional[str] = None,
        ensure_attempt_limit: int = 50,
        # Spec-driven generation configuration
        edge_t_per_quadrant: Optional[int] = None,
        central_l_per_quadrant: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.height = height
        self.width = width
        self.num_robots = num_robots
        self.include_noop = include_noop
        self.step_penalty = step_penalty
        self.goal_reward = goal_reward
        self.noop_penalty = step_penalty if noop_penalty is None else noop_penalty
        self.max_steps = max_steps
        self.fixed_layout = fixed_layout
        self.ensure_solvable = ensure_solvable
        self.solver_max_depth = solver_max_depth
        self.solver_max_nodes = solver_max_nodes
        self.obs_mode: ObsMode = obs_mode
        self.channels_first = channels_first
        # Render API
        self.render_mode = render_mode
        if self.render_mode is not None and self.render_mode not in self.metadata["render_modes"]:
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")

        # Seeding: adopt Gymnasium convention with self.np_random
        self.np_random: np.random.Generator
        self._episode_seed: Optional[int] = None
        try:  # gymnasium present
            # _seeding.np_random returns (rng, seed)
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else None
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed) if seed is not None else None
        self._board: Optional[Board] = None
        self._num_steps = 0
        self._cached_wall_obs: Optional[np.ndarray] = None  # (H,W,4) float32 for wall channels
        self._ensure_attempt_limit = int(ensure_attempt_limit)
        # Spec default counts per quadrant (based on smaller board side)
        side_min = min(self.height, self.width)
        default_per_quad = 2 if side_min < 10 else 4
        self._edge_t_per_quadrant = default_per_quad if edge_t_per_quadrant is None else int(edge_t_per_quadrant)
        self._central_l_per_quadrant = default_per_quad if central_l_per_quadrant is None else int(central_l_per_quadrant)

        # Observation spaces
        if self.obs_mode == "image":
            # channels: up_wall, down_wall, left_wall, right_wall, goal, target_mask, robots...
            self._base_wall_channels = 4
            self._base_misc_channels = 2  # goal, target
            self._num_channels = self._base_wall_channels + self._base_misc_channels + self.num_robots
            if self.channels_first:
                obs_shape = (self._num_channels, self.height, self.width)
            else:
                obs_shape = (self.height, self.width, self._num_channels)
            self.observation_space = spaces.Box(
                low=0.0,
                high=1.0,
                shape=obs_shape,
                dtype=np.float32,
            )
        elif self.obs_mode == "symbolic":
            # [goal_r, goal_c] in [0..H-1], [0..W-1]; one-hot target in [0,1]; robots positions in bounds
            vec_len = 2 + self.num_robots + (self.num_robots * 2)
            low = np.full((vec_len,), 0.0, dtype=np.float32)
            high = np.full((vec_len,), 1.0, dtype=np.float32)
            # goal bounds
            low[0] = 0.0
            high[0] = float(self.height - 1)
            low[1] = 0.0
            high[1] = float(self.width - 1)
            # target one-hot already [0,1]
            # robots positions
            base = 2 + self.num_robots
            for i in range(self.num_robots):
                low[base + 2 * i] = 0.0
                high[base + 2 * i] = float(self.height - 1)
                low[base + 2 * i + 1] = 0.0
                high[base + 2 * i + 1] = float(self.width - 1)
            self.observation_space = spaces.Box(low=low, high=high, shape=(vec_len,), dtype=np.float32)
        else:
            raise ValueError(f"Unknown obs_mode: {self.obs_mode}")

        # Action space: num_robots * 4 directions (+ 1 for noop)
        self._noop_action = self.num_robots * 4 if include_noop else None
        self.action_space = spaces.Discrete(self.num_robots * 4 + (1 if include_noop else 0))

    # Gymnasium API
    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):
        """Reset the environment and start a new episode.

        Returns (obs, info) per Gymnasium API. info contains keys: 'target_robot',
        'level_solvable' (optional), 'optimal_length' (if ensured), 'solver_limits' (if ensured),
        and 'episode_seed' with the seed used for this episode.
        """
        # Standard seeding protocol
        if seed is not None:
            try:
                self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
                self._episode_seed = int(used_seed) if used_seed is not None else None
            except NameError:
                self.np_random = np.random.default_rng(seed)
                self._episode_seed = int(seed)
        _ = options  # silence unused
        self._num_steps = 0
        # clear cached walls in case layout changes
        self._cached_wall_obs = None

        if self.fixed_layout is not None:
            self._board = Board(
                height=self.fixed_layout.height,
                width=self.fixed_layout.width,
                h_walls=self.fixed_layout.h_walls.copy(),
                v_walls=self.fixed_layout.v_walls.copy(),
                robot_positions=dict(self.fixed_layout.robot_positions),
                goal_position=self.fixed_layout.goal_position,
                target_robot=self.fixed_layout.target_robot,
            )
            # cache static walls for this layout
            self._build_cached_walls(self._board)
            obs = self._make_obs(self._board)
            info = {
                "level_solvable": False,
                "ensure_solvable_enabled": False,
                "target_robot": self._board.target_robot,
                "episode_seed": self._episode_seed,
            }
            if self.obs_mode == "image":
                info["channel_names"] = self.channel_names
            return obs, info

        # Otherwise, generate random board, optionally ensure solvable via solver
        attempts = 0
        while True:
            attempts += 1
            board = self._generate_random_board()
            if not self.ensure_solvable:
                self._board = board
                break
            try:
                from .solver import solve_bfs  # type: ignore
                solution = solve_bfs(board, max_depth=self.solver_max_depth, max_nodes=self.solver_max_nodes)
                if solution is not None:
                    self._board = board
                    optimal_length = len(solution)
                    break
            except ImportError as exc:
                raise RuntimeError("ensure_solvable=True but solver unavailable (ImportError)") from exc
            if attempts >= self._ensure_attempt_limit:
                raise RuntimeError("Failed to generate solvable board within attempt limit")

        # cache static walls for this layout
        assert self._board is not None
        self._build_cached_walls(self._board)
        obs = self._make_obs(self._board)
        # Note: solver None during attempts may be due to cutoffs (depth/nodes), not true unsolvability.
        info = {
            "level_solvable": bool(self.ensure_solvable),
            "ensure_solvable_enabled": bool(self.ensure_solvable),
            "target_robot": self._board.target_robot,
            "episode_seed": self._episode_seed,
        }
        if self.obs_mode == "image":
            info["channel_names"] = self.channel_names
        if self.ensure_solvable:
            info["optimal_length"] = optimal_length
            info["solver_limits"] = {"max_depth": self.solver_max_depth, "max_nodes": self.solver_max_nodes}
        return obs, info

    def step(self, action: int):
        """Apply an action and return (obs, reward, terminated, truncated, info).

        info always includes 'steps', 'target_robot', and 'is_success' (bool). When truncated due to
        max steps, info includes 'TimeLimit.truncated'=True.
        """
        assert self._board is not None, "Call reset() first"
        self._num_steps += 1

        terminated = False
        truncated = False
        info: Dict[str, object] = {}

        reward = self.step_penalty
        # Validate action range early
        if not (0 <= action < self.action_space.n):
            if GymInvalidAction is not None:
                raise GymInvalidAction(f"Invalid action {action}")  # type: ignore[misc]
            raise ValueError(f"Invalid action {action}")

        if self.include_noop and action == self._noop_action:
            reward = self.noop_penalty
        else:
            robot_id, direction = self._decode_action(action)
            self._board = apply_action(self._board, robot_id, direction)

        if reached_goal(self._board):
            reward += self.goal_reward
            terminated = True
            info["is_success"] = True

        if not terminated and self._num_steps >= self.max_steps:
            truncated = True
            info["TimeLimit.truncated"] = True

        obs = self._make_obs(self._board)
        info["steps"] = self._num_steps
        info["target_robot"] = self._board.target_robot
        if "is_success" not in info:
            info["is_success"] = False
        return obs, reward, terminated, truncated, info

    def render(self):
        """Render according to render_mode.

        - render_mode=="ascii": returns a string frame.
        - render_mode is None or unsupported: returns None.
        """
        if self.render_mode is None:
            return None
        if self.render_mode != "ascii":
            raise ValueError(f"Unsupported render_mode {self.render_mode}. Supported: {self.metadata['render_modes']}")
        if self._board is None:
            return ""
        from .ricochet_core import render_ascii  # local import to avoid circulars in lints
        return render_ascii(self._board)

    def close(self) -> None:
        """Close environment resources (no-op)."""
        return None

    def seed(self, seed: Optional[int] = None):  # legacy convenience
        """Legacy seeding helper returning [seed]. Prefer reset(seed=...)."""
        if seed is None:
            return [self._episode_seed]
        try:
            self.np_random, used_seed = _seeding.np_random(seed)  # type: ignore[name-defined]
            self._episode_seed = int(used_seed) if used_seed is not None else int(seed)
        except NameError:
            self.np_random = np.random.default_rng(seed)
            self._episode_seed = int(seed)
        return [self._episode_seed]

    # Helpers
    def _decode_action(self, action: int) -> Tuple[int, int]:
        if not (0 <= action < self.action_space.n):
            raise ValueError(f"Invalid action {action}")
        if self.include_noop and action == self._noop_action:
            raise ValueError("_decode_action called on noop action")
        robot_id = action // 4
        direction = action % 4
        if robot_id >= self.num_robots:
            raise ValueError(f"Invalid robot_id {robot_id} for action {action}")
        return robot_id, direction

    def _make_obs(self, board: Board) -> np.ndarray:
        if self.obs_mode == "image":
            return self._board_to_image_obs(board)
        return self._board_to_symbolic_obs(board)

    def _board_to_image_obs(self, board: Board) -> np.ndarray:
        h, w = board.height, board.width
        C = self._num_channels
        obs = np.zeros((h, w, C), dtype=np.float32)
        # wall channels 0..3 from cache
        if self._cached_wall_obs is not None:
            obs[:, :, 0:4] = self._cached_wall_obs
        else:
            # Fallback if cache not built (should not happen)
            for r in range(h):
                for c in range(w):
                    obs[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                    obs[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                    obs[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                    obs[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        # goal channel 4
        gr, gc = board.goal_position
        obs[gr, gc, 4] = 1.0
        # target mask channel 5
        tr = board.target_robot
        tr_r, tr_c = board.robot_positions[tr]
        obs[tr_r, tr_c, 5] = 1.0
        # robot channels start at 6
        base = 6
        for rid, (r, c) in board.robot_positions.items():
            obs[r, c, base + rid] = 1.0
        if self.channels_first:
            obs = np.transpose(obs, (2, 0, 1))
        return obs

    def _board_to_symbolic_obs(self, board: Board) -> np.ndarray:
        gr, gc = board.goal_position
        target_one_hot = np.zeros((self.num_robots,), dtype=np.float32)
        target_one_hot[board.target_robot] = 1.0
        robots_vec: List[float] = []
        for rid in range(self.num_robots):
            r, c = board.robot_positions[rid]
            robots_vec.extend([float(r), float(c)])
        vec = np.concatenate([
            np.array([float(gr), float(gc)], dtype=np.float32),
            target_one_hot.astype(np.float32),
            np.array(robots_vec, dtype=np.float32),
        ])
        return vec

    def _generate_random_board(self) -> Board:
        h, w = self.height, self.width
        assert h == w, "Boards should always be square per specification"
        # Initialize empty walls then set borders
        h_walls = np.zeros((h + 1, w), dtype=bool)
        v_walls = np.zeros((h, w + 1), dtype=bool)
        h_walls[0, :] = True
        h_walls[h, :] = True
        v_walls[:, 0] = True
        v_walls[:, w] = True

        # Track reserved cells that already host a structure (to satisfy rule: max 1 structure per cell)
        reserved_cells: Set[Tuple[int, int]] = set()

        # Helper to mark a cell as having a structure
        def reserve_cell(cell: Tuple[int, int]) -> None:
            r, c = cell
            if 0 <= r < h and 0 <= c < w:
                reserved_cells.add((r, c))

        # Build forbidden central block: walls surrounding central 1x1 (odd) or 2x2 (even)
        if h % 2 == 1:
            mid = h // 2
            # Walls around (mid, mid)
            h_walls[mid, mid] = True  # above
            h_walls[mid + 1, mid] = True  # below
            v_walls[mid, mid] = True  # left
            v_walls[mid, mid + 1] = True  # right
            reserve_cell((mid, mid))
            central_rows = [mid]
            central_cols = [mid]
        else:
            mid = h // 2
            # Central 2x2 cells: (mid-1, mid-1), (mid-1, mid), (mid, mid-1), (mid, mid)
            # Walls around the perimeter of this 2x2 block
            # Horizontal walls above and below the 2x2 block
            h_walls[mid, mid - 1] = True
            h_walls[mid, mid] = True
            h_walls[mid + 1, mid - 1] = True
            h_walls[mid + 1, mid] = True
            # Vertical walls left and right of the 2x2 block
            v_walls[mid - 1, mid] = True
            v_walls[mid, mid] = True
            v_walls[mid - 1, mid + 1] = True
            v_walls[mid, mid + 1] = True
            # Reserve the 2x2 central cells
            for rr in (mid - 1, mid):
                for cc in (mid - 1, mid):
                    reserve_cell((rr, cc))
            central_rows = [mid - 1, mid]
            central_cols = [mid - 1, mid]

        # Define quadrant bounds excluding the central rows/cols
        # Each bound is (r_start, r_end_inclusive, c_start, c_end_inclusive)
        def ranges_excluding_central(size: int, central_idxs: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
            # returns (low_range, high_range) as inclusive (start,end)
            unique = sorted(set(central_idxs))
            if len(unique) == 1:
                mid_idx = unique[0]
                return (0, mid_idx - 1), (mid_idx + 1, size - 1)
            else:
                # two central indices for even
                low_end = unique[0] - 1
                high_start = unique[1] + 1
                return (0, low_end), (high_start, size - 1)

        (r0_start, r0_end), (r1_start, r1_end) = ranges_excluding_central(h, central_rows)
        (c0_start, c0_end), (c1_start, c1_end) = ranges_excluding_central(w, central_cols)
        quadrants = {
            "NW": (r0_start, r0_end, c0_start, c0_end),
            "NE": (r0_start, r0_end, c1_start, c1_end),
            "SW": (r1_start, r1_end, c0_start, c0_end),
            "SE": (r1_start, r1_end, c1_start, c1_end),
        }

        # Placement helpers
        used_interior_h: Set[Tuple[int, int]] = set()  # (row_idx in 1..h-1, col_idx in 0..w-1)
        used_interior_v: Set[Tuple[int, int]] = set()  # (row_idx in 0..h-1, col_idx in 1..w)

        def can_place_h(row: int, col: int) -> bool:
            if not (1 <= row <= h - 1 and 0 <= col <= w - 1):
                return False
            if h_walls[row, col]:
                return False
            # Avoid touching non-border existing walls: ensure adjacent interior edges are free for central-L constraints
            neighbors = [
                (row - 1, col), (row + 1, col)
            ]
            for nr, nc in neighbors:
                if 1 <= nr <= h - 1 and 0 <= nc <= w - 1 and h_walls[nr, nc]:
                    return False
            return True

        def can_place_v(row: int, col: int) -> bool:
            if not (0 <= row <= h - 1 and 1 <= col <= w - 1):
                return False
            if v_walls[row, col]:
                return False
            neighbors = [
                (row, col - 1), (row, col + 1)
            ]
            for nr, nc in neighbors:
                if 0 <= nr <= h - 1 and 1 <= nc <= w - 1 and v_walls[nr, nc]:
                    return False
            return True

        def place_edge_t_in_quadrant(q_bounds: Tuple[int, int, int, int]) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            # Choose one of four sides from this quadrant that lies on the board boundary
            choices: List[Tuple[str, Tuple[int, int]]] = []
            # From top boundary within [cs..ce]: place vertical wall at row 0 between (0,c-1)-(0,c) as v_walls[0,c]
            if rs == 0:
                for c in range(cs + 1, ce + 1):
                    choices.append(("TOP", (0, c)))  # v_walls[0, c]
            # From bottom boundary
            if re == h - 1:
                for c in range(cs + 1, ce + 1):
                    choices.append(("BOTTOM", (h - 1, c)))  # v_walls[h-1, c]
            # From left boundary
            if cs == 0:
                for r in range(rs + 1, re + 1):
                    choices.append(("LEFT", (r, 0)))  # h_walls[r,0]
            # From right boundary
            if ce == w - 1:
                for r in range(rs + 1, re + 1):
                    choices.append(("RIGHT", (r, w - 1)))  # h_walls[r, w-1]
            if not choices:
                return False
            # Shuffle deterministically via self.np_random
            idxs = np.arange(len(choices))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                side, pos = choices[idx]
                if side in ("TOP", "BOTTOM"):
                    r0, c = pos
                    # Place vertical wall jutting down/up adjacent to border: v_walls[r0, c]
                    if can_place_v(r0, c):
                        v_walls[r0, c] = True
                        used_interior_v.add((r0, c))
                        # Reserve the adjacent interior cell touched by the jut
                        adj_cell = (1 if side == "TOP" else h - 2, c - 1)
                        reserve_cell(adj_cell)
                        return True
                else:
                    r, c0 = pos
                    # Place horizontal wall jutting right/left adjacent to border: h_walls[r, c0]
                    if can_place_h(r, c0):
                        h_walls[r, c0] = True
                        used_interior_h.add((r, c0))
                        adj_cell = (r - 1, 1 if side == "LEFT" else w - 2)
                        reserve_cell(adj_cell)
                        return True
            return False

        # Central-L orientations
        # orientation encodes which two walls around a cell: TL => top+left, TR => top+right, BL => bottom+left, BR => bottom+right
        orientations = ["TL", "TR", "BL", "BR"]

        def place_central_l_in_quadrant(q_bounds: Tuple[int, int, int, int], desired_orientation: str) -> bool:
            rs, re, cs, ce = q_bounds
            if rs > re or cs > ce:
                return False
            candidates: List[Tuple[int, int]] = []
            for r in range(rs, re + 1):
                for c in range(cs, ce + 1):
                    # Central-L cannot be around an edge square
                    if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                        continue
                    if (r, c) in reserved_cells:
                        continue
                    candidates.append((r, c))
            if not candidates:
                return False
            idxs = np.arange(len(candidates))
            self.np_random.shuffle(idxs)
            for idx in idxs:
                r, c = candidates[idx]
                # Determine which interior edges would be used by the L at this cell
                need_h: Optional[Tuple[int, int]] = None
                need_v: Optional[Tuple[int, int]] = None
                if desired_orientation == "TL":
                    need_h = (r, c)  # top wall above the cell
                    need_v = (r, c)  # left wall of the cell
                elif desired_orientation == "TR":
                    need_h = (r, c)  # top
                    need_v = (r, c + 1)  # right wall uses v_walls[r, c+1]
                elif desired_orientation == "BL":
                    need_h = (r + 1, c)  # bottom wall below the cell
                    need_v = (r, c)  # left
                else:  # "BR"
                    need_h = (r + 1, c)
                    need_v = (r, c + 1)
                # Check within interior ranges and not touching other interior walls
                if need_h is None or need_v is None:
                    continue
                hr, hc = need_h
                vr, vc = need_v
                if not can_place_h(hr, hc):
                    continue
                if not can_place_v(vr, vc):
                    continue
                # Also ensure the required edges are not on the outer border (to avoid touching existing walls per spec)
                if hr in (0, h) or vc in (0, w):
                    continue
                # Place them
                h_walls[hr, hc] = True
                v_walls[vr, vc] = True
                used_interior_h.add((hr, hc))
                used_interior_v.add((vr, vc))
                # Reserve the corner cell for structure uniqueness
                reserve_cell((r, c))
                return True
            return False

        # Place structures per quadrant
        # 1) Edge-T
        for _, bounds in quadrants.items():
            count = self._edge_t_per_quadrant
            placed = 0
            # Attempt multiple times to place required count
            attempts = 0
            while placed < count and attempts < count * 10:
                if place_edge_t_in_quadrant(bounds):
                    placed += 1
                attempts += 1

        # 2) Central-L with as even orientation distribution as possible
        for _, bounds in quadrants.items():
            count = self._central_l_per_quadrant
            if count <= 0:
                continue
            # Build orientation list as evenly as possible
            orient_list: List[str] = []
            for i in range(count):
                orient_list.append(orientations[i % 4])
            # Shuffle list deterministically for variety across seeds
            idxs = np.arange(len(orient_list))
            self.np_random.shuffle(idxs)
            orient_list = [orient_list[i] for i in idxs]
            placed = 0
            attempts = 0
            i = 0
            while placed < count and attempts < count * 20 and i < len(orient_list):
                if place_central_l_in_quadrant(bounds, orient_list[i]):
                    placed += 1
                i += 1
                attempts += 1

        # Place goal and robots in free cells, excluding central block cells
        free_cells: List[Tuple[int, int]] = []
        central_set = set((r, c) for r in central_rows for c in central_cols)
        for r in range(h):
            for c in range(w):
                if (r, c) in central_set:
                    continue
                free_cells.append((r, c))
        self.np_random.shuffle(free_cells)
        goal = free_cells.pop()
        robot_positions: Dict[int, Tuple[int, int]] = {}
        for rid in range(self.num_robots):
            robot_positions[rid] = free_cells.pop()
        target_robot = int(self.np_random.integers(0, self.num_robots))
        return Board(height=h, width=w, h_walls=h_walls, v_walls=v_walls, robot_positions=robot_positions, goal_position=goal, target_robot=target_robot)

    # Public channel names for image observations
    @property
    def channel_names(self) -> List[str]:
        """Human-readable names for image observation channels."""
        names = ["wall_up", "wall_down", "wall_left", "wall_right", "goal", "target_robot_mask"]
        names.extend([f"robot_{i}" for i in range(self.num_robots)])
        return names

    def _build_cached_walls(self, board: Board) -> None:
        """Precompute static wall indicator channels (H,W,4)."""
        h, w = board.height, board.width
        wall = np.zeros((h, w, 4), dtype=np.float32)
        for r in range(h):
            for c in range(w):
                wall[r, c, 0] = 1.0 if board.has_wall_up(r, c) else 0.0
                wall[r, c, 1] = 1.0 if board.has_wall_down(r, c) else 0.0
                wall[r, c, 2] = 1.0 if board.has_wall_left(r, c) else 0.0
                wall[r, c, 3] = 1.0 if board.has_wall_right(r, c) else 0.0
        self._cached_wall_obs = wall


# Optional helper for registration with gymnasium
def register_env(env_id: str = "RicochetRobots-v0", *, max_episode_steps: Optional[int] = None) -> None:
    """Register this environment with gymnasium so it can be created via gym.make(env_id).

    Note: This env already enforces a time limit via its max_steps argument. If you also set
    max_episode_steps here and wrap with Gym's TimeLimit implicitly via gym.make, you may see
    duplicate truncation behavior. Prefer one source of time limits.
    """
    try:
        from gymnasium.envs.registration import register  # type: ignore
        from gymnasium.error import Error as GymError  # type: ignore
        try:
            kwargs = {}
            if max_episode_steps is not None:
                kwargs["max_episode_steps"] = int(max_episode_steps)
            register(
                id=env_id,
                entry_point="env.ricochet_env:RicochetRobotsEnv",
                **kwargs,
            )
        except GymError as e:  # pragma: no cover - depends on gym version behavior
            # Swallow duplicate registration errors; re-raise others
            if "already registered" in str(e).lower():
                return
            raise
    except (ModuleNotFoundError, ImportError):
        # Silently ignore if gymnasium not available
        pass

```

Done. Central-L placement now skips edge cells, so no central-L can be around an edge square.

- Updated `place_central_l_in_quadrant` to filter out edge cells before considering candidates.
- Lints clean.

Want me to add tests to assert this constraint?

